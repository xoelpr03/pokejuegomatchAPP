<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shiny Match</title>
    <style>
        :root {
            --bg: #0f172a;
            --card-bg: rgba(255, 255, 255, 0.98);
            --text-main: #1e293b;
            --accent: #3b82f6;
            --success: #10b981;
            --danger: #ef4444;
            --shiny-gold: #fbbf24;
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
    background: radial-gradient(circle at top, #1e293b 0%, #0f172a 100%);
    color: #f8fafc;
    margin: 0;
    display: flex;
    justify-content: center; /* Centrado horizontal */
    align-items: center;     /* Centrado vertical */
    min-height: 100vh;
    width: 100vw;
    overflow: hidden;
        }

        /* --- MENU STYLES --- */
        .menu-card {
            background: var(--card-bg);
            width: 90%;
            max-width: 350px;
            padding: 30px 20px;
            border-radius: 24px;
            box-shadow: 0 20px 40px -10px rgba(0,0,0,0.5);
            text-align: center;
            color: var(--text-main);
            z-index: 100;
        }

        .menu-title {
            font-size: 28px; font-weight: 900; margin: 10px 0 5px 0; text-transform: uppercase;
            background: linear-gradient(135deg, #ef4444 0%, #3b82f6 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .btn-group { display: flex; flex-direction: column; gap: 12px; }

        .menu-btn {
            width: 100%; height: 50px; border-radius: 12px; font-size: 14px; font-weight: 800;
            cursor: pointer; border: none; text-transform: uppercase; transition: 0.2s;
            display: flex; align-items: center; justify-content: center; text-decoration: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mode-play { background: #3b82f6; color: white; font-size: 18px; }
        .mode-how { background: #f1f5f9; color: #475569; border: 2px solid #e2e8f0; }
        .mode-dex { background: #fbbf24; color: #78350f; }
        .exit-link-btn { background: #64748b; color: white; }

        .mute-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white; border: 1px solid rgba(255, 255, 255, 0.2);
            width: 40px; height: 40px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 18px; transition: 0.3s;
        }
        .mute-btn.active { background: var(--danger); border-color: transparent; }

        /* --- MODAL STYLES --- */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            color: var(--text-main);
            width: min(90vw, 520px);
            max-height: 80vh;
            padding: clamp(18px, 4vw, 30px);
            border-radius: 20px;
            text-align: center;
            overflow: hidden;
        }

        #dex-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(56px, 1fr));
    gap: clamp(6px, 1.5vw, 10px);
    max-height: 45vh;
    overflow-y: auto;
    margin: 15px 0;
    padding: 10px;
    background: #f1f5f9;
    border-radius: 12px;
}

.dex-slot {
    position: relative;
    background: white;
    border-radius: 8px;
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #e2e8f0;
    overflow: hidden;
}

.dex-num {
    position: absolute;
    top: 2px;
    left: 3px;
    font-size: 8px;
    font-weight: 900;
    color: #cbd5e1; /* Color suave para el n√∫mero */
    z-index: 1;
}

.dex-img {
    width: 90%;
    height: auto;
    image-rendering: pixelated;
    transition: transform 0.2s;
}

.not-caught .dex-img {
    filter: brightness(0);
    opacity: 0.3;
}

.caught {
    background: #ffffff;
    border-color: #fde047; /* Borde amarillo para capturados */
    box-shadow: inset 0 0 10px rgba(254, 252, 232, 0.5);
}

.caught .dex-num {
    color: #94a3b8; /* N√∫mero m√°s visible si est√° capturado */
}
        /* --- GAME SCREEN --- */
        #game-screen {  
    display: none; 
    flex-direction: column;
    justify-content: center; /* Centra el contenido internamente */
    align-items: center;
    width: 100%; 
    max-width: 500px; 
    height: 100vh; /* Ocupa el alto total para centrar respecto a la pantalla */
    padding: 20px; 
    box-sizing: border-box;
    position: relative;
}
        

        #game-over-overlay {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 24px;
            animation: fadeIn 0.3s ease;
            text-align: center;
            padding: 20px;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        #header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        #score-box { text-align: left; }
        #score-label { font-size: 10px; color: #94a3b8; font-weight: 800; }
        #score { font-size: 28px; font-weight: 900; color: #fbbf24; line-height: 1; }

       canvas {
    width: 100%;
    /* Forzamos relaci√≥n de aspecto cuadrada */
    aspect-ratio: 1 / 1; 
    
    max-width: 450px; /* Tama√±o m√°ximo para que no desborde en PC */
    max-height: 450px; 
    
    background: #1e293b; 
    border: 4px solid #475569;
    border-radius: 20px; 
    image-rendering: pixelated;
    touch-action: none; 
    cursor: crosshair;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    
    /* Eliminamos el height: auto previo para que no interfiera */
    height: unset !important; 
}
.score-container, #status, .region-title {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    color: white;
}

        #shiny-tracker {
            margin-top: 15px;
    width: 100%;
    max-width: 400px; /* Alineado con el canvas */
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 8px;
    max-height: 120px; /* Altura m√°xima para que no crezca infinitamente */
    overflow-y: auto;
        }
        #shiny-label { font-size: 10px; color: #94a3b8; font-weight: 800; text-align: left; margin-bottom: 5px;}
        #shiny-list, #final-shiny-list { display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; }

        .shiny-icon { 
            width: 35px; 
            height: 35px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 8px; 
            image-rendering: pixelated; 
        }

        #status { font-size: 12px; color: #fbbf24; margin-top: 5px; font-weight: 800; height: 15px; text-transform: uppercase; }
        
        #loading-msg { 
            position: fixed; inset: 0; background: #0f172a; 
            display: none; align-items: center; justify-content: center; 
            z-index: 2000; font-weight: 900; letter-spacing: 2px;
        }

        .creator-credit {
            margin-top: 25px; font-size: 9px; font-weight: 800; text-transform: lowercase;
            letter-spacing: 2px; color: #94a3b8; opacity: 0.6; text-align: center;
            border-top: 1px solid #e2e8f0; padding-top: 12px; width: 180px; margin: 25px auto 0;
        }

        .shiny-alert {
    animation: shinyBlink 0.6s infinite alternate;
    text-shadow: 0 0 10px #fff, 0 0 20px #60a5fa;
}

@keyframes shinyBlink {
    from { opacity: 1; transform: scale(1); }
    to { opacity: 0.7; transform: scale(1.05); }
}

        #who-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
    max-height: 45vh;
    overflow-y: auto;
    margin: 15px 0;
    padding: 10px;
    background: #f1f5f9;
    border-radius: 12px;
}

.dex-img, .who-item img {
    width: clamp(40px, 12vw, 64px);
    height: clamp(40px, 12vw, 64px);
    image-rendering: crisp-edges;
    object-fit: contain;
}

.who-name {
    font-size: 10px;
    font-weight: 800;
    text-transform: uppercase;
    color: var(--accent);
    margin-top: 4px;
}

.quit-btn {
    background: rgba(255, 255, 255, 0.1);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 18px;
    transition: 0.3s;
    outline: none;
}

.quit-btn:hover {
    background: rgba(239, 68, 68, 0.25);
    border-color: rgba(239, 68, 68, 0.6);
    transform: scale(1.08);
}

.quit-btn:active {
    transform: scale(0.95);
}

#gameCanvas {
    touch-action: none; /* Esto es vital para que el swipe funcione en m√≥viles */
}
#berry-guide-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin: 15px 0;
    text-align: left;
    max-height: 50vh;
    overflow-y: auto;
    padding: 10px;
}

.berry-row {
    display: flex;
    align-items: center;
    gap: 15px;
    background: #f8fafc;
    padding: 10px;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
}

.berry-row img {
    width: 40px;
    height: 40px;
    image-rendering: pixelated;
}

.berry-info h4 {
    margin: 0;
    font-size: 14px;
    color: var(--text-main);
    text-transform: uppercase;
}

.berry-info p {
    margin: 2px 0 0 0;
    font-size: 11px;
    color: #64748b;
    font-weight: 600;
}

/* --- Multiplier Timer Styling --- */
#multiplier-timer {
    background: rgba(251, 191, 36, 0.15); /* Light gold transparency */
    border: 1px solid var(--shiny-gold);
    padding: 5px 15px;
    border-radius: 20px;
    margin-bottom: 10px;
    box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
    animation: pulse-glow 2s infinite ease-in-out;
}

#timer-count {
    font-variant-numeric: tabular-nums; /* Prevents text jumping when numbers change */
    color: #fff;
    text-shadow: 0 0 5px var(--shiny-gold);
}

@keyframes pulse-glow {
    0% { transform: scale(1); box-shadow: 0 0 10px rgba(251, 191, 36, 0.3); }
    50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(251, 191, 36, 0.5); }
    100% { transform: scale(1); box-shadow: 0 0 10px rgba(251, 191, 36, 0.3); }
}
.tutorial-body {
    text-align: left;
    max-height: 60vh;
    overflow-y: auto;
    padding: 15px;
    color: white;
}

.tutorial-body h3 {
    color: #f97316; /* Orange color to stand out */
    margin-bottom: 5px;
    font-size: 1.1em;
    text-transform: uppercase;
}

.tutorial-body p {
    font-size: 0.95em;
    line-height: 1.5;
    margin-bottom: 12px;
    color: #cbd5e1;
}

hr { 
    border: 0; 
    border-top: 1px solid #475569; 
    margin: 15px 0; 
}

/* Ensure buttons look consistent with your theme */
.close-btn {
    background: #22c55e;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    margin-top: 10px;
}

/* Fondos por Regi√≥n */
.bg-default { background: linear-gradient(135deg, #2c3e50, #000000); }
.bg-kanto   { background: linear-gradient(135deg, #560000, #00004e); } /* Rojo, Azul, Amarillo */
.bg-johto   { background: linear-gradient(135deg, #4c3f13, #403f41); }         /* Oro, Plata */
.bg-hoenn   { background: linear-gradient(135deg, #430000, #051a3b, #122f1c); } /* Rub√≠, Zafiro, Esmeralda */
.bg-sinnoh  { background: linear-gradient(135deg, #42565a, #482243); }         /* Diamante, Perla */
.bg-unova   { background: linear-gradient(135deg, #565656, #000000); }         /* Blanco, Negro */
.bg-kalos   { background: linear-gradient(135deg, #00003b, #350708); }         /* Azul Oscuro, Granate (X/Y) */
.bg-alola   { background: linear-gradient(135deg, #593100, #220437); }         /* Naranja, Morado (Sol/Luna) */
.bg-galar   { background: linear-gradient(135deg, #062f42, #460018); } /* Cian, Amarillo, Magenta */
.bg-paldea  { background: linear-gradient(135deg, #410900, #300038); }         /* Escarlata, P√∫rpura */

/* Aseg√∫rate de que el fondo cubra toda la pantalla */
#game-screen, body {
    transition: background 0.5s ease; /* Transici√≥n suave al cambiar */
    min-height: 100vh;
}
.combo-multiplier {
    position: absolute;
    color: yellow; /* O un color brillante para el combo */
    font-size: 2.5em;
    font-weight: bold;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
    pointer-events: none; /* Ignorar clics */
    opacity: 0; /* Empieza invisible */
    animation: comboFadeInUp 1s forwards; /* Animaci√≥n de subida y desvanecimiento */
    z-index: 100;
}

@keyframes comboFadeInUp {
    0% {
        opacity: 0;
        transform: translate(-50%, 0px); /* Centrado horizontal, posici√≥n inicial */
    }
    30% {
        opacity: 1;
        transform: translate(-50%, -20px); /* Sube un poco */
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50px); /* Sube m√°s y desaparece */
    }
}

/* Estilo del Fantasmita de Combo */
.combo-ghost {
    position: fixed; /* Importante para que use las coordenadas X e Y de la pantalla */
    z-index: 2000;
    font-family: inherit; 
    font-size: 3rem;
    font-weight: 900;
    color: rgba(255, 255, 255, 0.8);
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 2px 2px 0px rgba(0,0,0,0.3);
    pointer-events: none;
    user-select: none;
    transform: translate(-50%, -50%);
    animation: ghostFloat 1.2s ease-out forwards, ghostSway 0.4s ease-in-out infinite alternate;
}

/* El fantasmita de x5 es m√°s grande y brillante */
.combo-ghost.max-ghost {
    color: rgba(255, 215, 0, 0.9); /* Dorado fantasmal */
    font-size: 4.5rem;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
}

/* Estilo base del recuadro (igual para ambos) */
.timer-box {
    padding: 5px 15px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 900;
    text-align: center;
    border: 2px solid;
    min-width: 180px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    background: rgba(0, 0, 0, 0.7); /* Fondo oscuro para que resalte el texto */
}

/* Identidad Sitrus (Naranja/Oro) */
.sitrus-style {
    color: #fbbf24;
    border-color: #fbbf24;
    box-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
}

/* Identidad Lum (Plata/Shiny) */
.lum-style {
    color: #e2e8f0; /* Gris muy claro / Blanco azulado */
    border-color: #94a3b8;
    box-shadow: 0 0 10px rgba(226, 232, 240, 0.4);
    animation: shinyGlow 1.5s infinite alternate;
}

@keyframes shinyGlow {
    from { box-shadow: 0 0 5px rgba(226, 232, 240, 0.4); }
    to { box-shadow: 0 0 15px rgba(255, 255, 255, 0.8); }
}

/* Animaci√≥n de subida y desaparici√≥n */
@keyframes ghostFloat {
    0% {
        opacity: 0;
        margin-top: 20px;
        scale: 0.5;
    }
    20% {
        opacity: 1;
        scale: 1.2;
    }
    100% {
        opacity: 0;
        margin-top: -150px; /* Sube hacia el cielo */
        scale: 1;
    }
}
.btn-share {
    background: #3b82f6; /* Action blue */
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 12px;
    font-weight: bold;
    font-size: 1rem;
    cursor: pointer;
    margin-top: 15px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-shadow: 0 4px 0px #1d4ed8; /* Darker blue shadow for 3D effect */
    width: 100%; /* Makes it easy to click on mobile */
    max-width: 250px;
}

.btn-share:hover {
    background: #2563eb;
    transform: translateY(-2px);
    box-shadow: 0 6px 0px #1d4ed8;
}

.btn-share:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0px #1d4ed8;
}

/* Optional: Add a pulse animation to draw attention to the highscore */
@keyframes pulse-gold {
    0% { text-shadow: 0 0 5px #fbbf24; }
    50% { text-shadow: 0 0 20px #fbbf24; }
    100% { text-shadow: 0 0 5px #fbbf24; }
}

#final-score {
    color: #fbbf24;
    animation: pulse-gold 2s infinite;
}
/* Animaci√≥n de balanceo lateral (efecto flotante) */
@keyframes ghostSway {
    from { transform: translate(-60%, -50%) rotate(-5deg); }
    to { transform: translate(-40%, -50%) rotate(5deg); }
}

#give-up-btn {
    pointer-events: auto; /* Re-enables clicks for the button itself */
    background: #ef4444; /* Red color */
    color: white;
    border: 2px solid #7f1d1d;
    padding: 8px 16px;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    font-family: 'Segoe UI', Arial, sans-serif;
    transition: transform 0.1s, background 0.2s;
    box-shadow: 0 4px 0 #991b1b;
}

#give-up-btn:hover {
    background: #dc2626;
}

#give-up-btn:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #991b1b;
}
.shiny-scroll-container {
    background: rgba(15, 23, 42, 0.6); /* Dark semi-transparent background */
    border: 2px solid #334155;
    border-radius: 12px;
    padding: 10px;
    
    /* SCROLL LOGIC */
    max-height: 180px; /* Adjust this height based on your preference */
    overflow-y: auto;  /* Vertical scroll only */
    overflow-x: hidden;
}

/* Ensure the list inside uses a grid layout for the icons */
#final-shiny-list {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 3 icons per row */
    gap: 12px;
    justify-items: center;
}

/* Custom scrollbar for a "gamer" look */
.shiny-scroll-container::-webkit-scrollbar {
    width: 6px;
}
.shiny-scroll-container::-webkit-scrollbar-thumb {
    background: #fbbf24; /* Yellow like a shiny star */
    border-radius: 10px;
}
.shiny-scroll-container::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
}

/* Style the icons inside the scroll box */
#final-shiny-list img {
    width: 50px;
    height: 50px;
    object-fit: contain;
    filter: drop-shadow(0 0 5px rgba(251, 191, 36, 0.3));
}
    </style>
</head>
<body>

    <div id="loading-msg">FETCHING POK√âMON...</div>

    <div id="dex-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="color: var(--shiny-gold); margin-top: 0;">‚ú® SHINY POK√âDEX ‚ú®</h3>
            <p id="dex-count" style="font-size: 12px; font-weight: 800; color: #64748b;"></p>
            <div id="dex-grid"></div>
            <button class="menu-btn exit-link-btn" onclick="closeModals()">CLOSE</button>
        </div>
    </div>

    <div id="berry-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="color: var(--success); margin-top: 0;">BERRY EFFECTS</h3>
        <div id="berry-guide-list">
            </div>
        <button class="menu-btn mode-play" onclick="closeModals()">GOT IT!</button>
    </div>
</div>

    <div id="main-menu" class="menu-card">
    <div style="font-size: 50px; margin-bottom: 10px;">‚ú®</div>
    <h1 class="menu-title">Shiny Match</h1>
    <p style="font-size: 11px; margin-bottom: 20px; font-weight: 600; color: #64748b;">SHINY ODDS: 1/100</p>
    <div class="btn-group">
        <button class="menu-btn mode-play" onclick="openRegionMenu()">Start Hunt</button>
        <button id="continue-btn" class="menu-btn mode-play" style="background: #10b981; display: none;" onclick="continueGame()">Continue Hunting</button>
        
        <button class="menu-btn" style="background: #6366f1;" onclick="openTutorial()">How to Play</button>
        
        <button class="menu-btn mode-dex" onclick="openDex()">Shiny Pokedex</button>
    </div>
    <div class="creator-credit">created by ŒæawsjŒ±ke</div>
</div>

    <div id="game-screen">
        <div id="game-over-overlay">
            <h2 style="color: var(--danger); font-size: 40px; margin-bottom: 5px; font-weight: 900;">GAME OVER</h2>
            <p style="font-size: 20px; font-weight: 800; margin-bottom: 10px;">SCORE: <span id="final-streak">0</span></p>
            
            <div id="game-over-shinies" style="margin-bottom: 20px;">
    <div style="font-size: 10px; color: #94a3b8; font-weight: 800; margin-bottom: 10px;">SHINIES COLLECTED</div>
    <div class="shiny-scroll-container">
        <div id="final-shiny-list"></div>
    </div>
</div>

            <div class="btn-group" style="width: 220px;">
                <button class="menu-btn mode-play" onclick="startGame()">Try Again</button>
                <button class="menu-btn exit-link-btn" onclick="resetToMenu()">Main Menu</button>
                <button onclick="downloadScoreImage()" class="btn-share">
    SAVE IMAGE üì•
</button>
            </div>
        </div>

        <div id="header">
            <div id="score-box">
                <div id="score-label">SCORE</div>
                <div id="score">0</div>
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <div id="who-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="color: var(--accent); margin-top: 0;">Who's That Pok√©mon?</h3>
        <div id="who-grid"></div>
        <button class="menu-btn mode-play" onclick="closeModals()">BACK TO HUNT</button>
    </div>
</div>

<button class="menu-btn mode-how" style="width: 40px; height: 40px; border-radius: 50%; font-size: 18px; background: #10b981; color: white;" onclick="openBerryGuide()">üçí</button>
<button class="menu-btn mode-dex" style="width: 40px; height: 40px; border-radius: 50%; font-size: 18px;" onclick="openWho()">‚ùì</button>
                <button id="muteBtn" class="mute-btn" onclick="toggleMute()">üîä</button>
                <button class="quit-btn" onclick="quitAndSave()">‚úï</button>
                <button id="give-up-btn" class="give-up-btn" onclick="giveUp()">üè≥Ô∏è Give Up</button>
        
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>
        <div id="multiplier-timer" style="display: none; font-size: 14px; font-weight: 900; color: #fbbf24; margin-bottom: 5px;">
        ‚ú® x2 POINTS: <span id="timer-count">60</span>s
    </div>
    <div id="lum-timer" class="timer-box lum-style" style="display: none;">
        ‚ú® SHINY BOOST: <span id="lum-count">10</span>s
    </div>
        <div id="status">SWIPE TO MATCH</div>

        <div id="shiny-tracker">
            <div id="shiny-label">SHINIES CAPTURED</div>
            <div id="shiny-list"></div>
        </div>
    </div>
    <div id="tutorial-modal" class="modal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 1000; align-items: center; justify-content: center; padding: 20px;">
    <div class="modal-content" style="background: #1e293b; border: 2px solid #475569; border-radius: 15px; width: 100%; max-width: 400px; padding: 20px; color: white;">
        <h2 style="color: #eab308; margin-top: 0; text-align: center;">üéÆ How To Play?</h2>
        
        <div style="max-height: 60vh; overflow-y: auto; text-align: left; font-size: 14px; line-height: 1.5;">
            <p><strong>‚ú® Catch Shinies:</strong> Swipe in any direction to match 3 or more Pok√©mon. Match a <b>Shiny</b> and it‚Äôs added to your permanent Dex!</p>

<p><strong>üåà Ditto:</strong> The ultimate wild card! It can match any color to help you complete lines.</p>

<p><strong>üçí Berries:</strong> Match them with Pok√©mon to trigger special powers, like clearing lines or doubling your points!</p>

<p><strong>üîÑ Idle Hints:</strong> Stuck? After 10 seconds of no moves, a piece will <b>rotate</b> to show you a valid match.</p>

        </div>

        <button class="menu-btn" style="background: #ef4444; width: 100%; margin-top: 15px;" onclick="closeModals()">Got it!</button>
    </div>
</div>
<div id="region-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content" style="max-width: 350px;">
        <h3 style="color: var(--accent); margin-top: 0;">SELECT REGION</h3>
        <div id="region-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
            <button class="region-btn" onclick="selectRegion('kanto')">Kanto</button>
            <button class="region-btn" onclick="selectRegion('johto')">Johto</button>
            <button class="region-btn" onclick="selectRegion('hoenn')">Hoenn</button>
            <button class="region-btn" onclick="selectRegion('sinnoh')">Sinnoh</button>
            <button class="region-btn" onclick="selectRegion('unova')">Unova</button>
            <button class="region-btn" onclick="selectRegion('kalos')">Kalos</button>
            <button class="region-btn" onclick="selectRegion('alola')">Alola</button>
            <button class="region-btn" onclick="selectRegion('galar')">Galar & Hisui</button>
            <button class="region-btn" onclick="selectRegion('paldea')">Paldea</button>
            
            <button class="region-btn" onclick="selectRegion('all')" style="grid-column: span 3; background: var(--accent); color: #000; font-weight: bold; margin-top: 5px;">ANY</button>
        </div>
        <button class="menu-btn exit-link-btn" onclick="closeModals()">CANCEL</button>
    </div>
</div>

<style>
    .region-btn {
        background: #334155;
        border: 2px solid #475569;
        color: white;
        padding: 15px 5px;
        border-radius: 8px;
        font-weight: 800;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
    }
    .region-btn:hover {
        background: var(--accent);
        border-color: white;
        transform: scale(1.05);
    }
</style>

<audio id="bgAudio" preload="auto"></audio>

<script>
let sessionShiniesCaught = new Set(); 
let hasShownSessionPopup = false; // Se reinicia cada vez que abres el juego
    const tutorialModal = document.getElementById('tutorial-modal');
    const DITTO_CHANCE = 0.01;
    const DITTO_IMAGE = new Image(); DITTO_IMAGE.src = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png';
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const statusEl = document.getElementById('status');
const loadingEl = document.getElementById('loading-msg');
const mainMenu = document.getElementById('main-menu');
const gameScreen = document.getElementById('game-screen');
const gameOverOverlay = document.getElementById('game-over-overlay');
const finalScoreEl = document.getElementById('final-streak');
const shinyListEl = document.getElementById('shiny-list');
const finalShinyListEl = document.getElementById('final-shiny-list');
const muteBtn = document.getElementById('muteBtn');
const whoModal = document.getElementById('who-modal');
const whoGrid = document.getElementById('who-grid');
const dexModal = document.getElementById('dex-modal');
const dexGrid = document.getElementById('dex-grid');
const dexCount = document.getElementById('dex-count');
let lumInterval = null;
let lumActive = false;
let multiplierInterval = null;
let currentCombo = 0;
const SHINY_SOUND = new Audio('https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3');
SHINY_SOUND.volume = 1;
const POP_SOUND_SOFT = new Audio('https://freesound.org/data/previews/411/411639_5121236-lq.mp3');
POP_SOUND_SOFT.volume = 0.7;
let scoreMultiplier = 1
let isMuted = false;
const GRID_SIZE = 7; 
let SHINY_CHANCE = 100;
let TILE_SIZE = 0;
let board = [];
let score = 0;
let isAnimating = false;
let gameOver = false;
let lastMoveTime = Date.now();
let gameInitialized = false;
let startX = null, startY = null;
let sparkles = [];
let pokemonData = [];
let pokemonColors = [];
let idleRotatingTile = null;
let allShiniesMessageShown = false;
const colors = ["#ef4444", "#f97316", "#eab308", "#22c55e", "#06b6d4", "#ec4899"];
const REGIONAL_IDS = [10091, 10092, 10100, 10101, 10102, 10103, 10104, 10105, 10106, 10107, 10108, 10109, 10110, 10111, 10112, 10113, 10114, 10115, 10161, 10162, 10163, 10164, 10165, 10166, 10167, 10168, 10169, 10170, 10171, 10172, 10173, 10174, 10175, 10176, 10177, 10179, 10180, 10229, 10230, 10231, 10232, 10233, 10234, 10235, 10236, 10237, 10238, 10239, 10240, 10241, 10242, 10243, 10244, 10250, 10253];
const DITTO_CRY = new Audio('https://raw.githubusercontent.com/PokeAPI/stock-pokemon-cries/master/cries/pokemon/latest/132.ogg');
DITTO_CRY.volume = 0.5; // Adjust volume as needed
let caughtShinies = JSON.parse(localStorage.getItem('shinyDex')) || {};
const musicFiles = [
  'audio/accumula.mp3',
  'audio/autumn.mp3',
  'audio/calyrex.mp3',
  'audio/celadon.mp3',
  'audio/ecruteak.mp3',
  'audio/hauoli.mp3',
  'audio/hooh.mp3',
  'audio/jacinthe.mp3',
  'audio/jubilife.mp3',
  'audio/lake.mp3',
  'audio/levincia.mp3',
  'audio/lugia.mp3',
  'audio/lumiose.mp3',
  'audio/mauville.mp3',
  'audio/relic.mp3',
  'audio/route.mp3',
  'audio/sonia.mp3',
  'audio/stow.mp3',
  'audio/treasure.mp3',
  'audio/wild.mp3'
];
const regionRanges = {
    'kanto':  { start: 1, end: 151 },
    'johto':  { start: 152, end: 251 },
    'hoenn':  { start: 252, end: 386 },
    'sinnoh': { start: 387, end: 493 },
    'unova':  { start: 494, end: 649 },
    'kalos':  { start: 650, end: 721 },
    'alola':  { 
        start: 722, 
        end: 809, 
        extras: REGIONAL_IDS.filter(id => id >= 10091 && id <= 10115) 
    },
    'galar':  { 
        // Abarca desde Grookey (810) hasta Enamorus (905)
        start: 810, 
        end: 905, 
        // Incluye formas de Galar (10161-10180), formas de Hisui (10223-10242) 
        // y los extras de Galar (10229-10232)
        extras: REGIONAL_IDS.filter(id => (id >= 10161 && id <= 10180) || (id >= 10223 && id <= 1024) || (id >= 10229 && id <= 10244)) 
    },
    'paldea': { 
        // Paldea empieza estrictamente en Sprigatito (906)
        start: 906, 
        end: 1025, 
        extras: REGIONAL_IDS.filter(id => id >= 10250) 
    }
};


async function selectRegion(regionKey) {
    // --- NUEVO: LIMPIEZA TOTAL DE PARTIDA ANTERIOR ---
    resetSessionUI(); 
    updateBackground(regionKey);
    gameOver = false; // Aseguramos que el estado de juego est√© activo
    
    // 1. Limpiar datos de l√≥gica previos
    pokemonData = []; 
    pokemonColors = [];

    if (regionKey === 'all') {
        // CASO ESPECIAL: Todas las regiones y todas las formas
        const baseIds = Array.from({length: 1025}, (_, i) => i + 1);
        currentRegionIds = [...baseIds, ...REGIONAL_IDS];
    } else {
        // CASO NORMAL: Regi√≥n espec√≠fica
        const range = regionRanges[regionKey];
        if (!range) return;

        const baseIds = Array.from({length: range.end - range.start + 1}, (_, i) => i + range.start);
        const extraIds = range.extras || [];
        currentRegionIds = [...baseIds, ...extraIds];
    }

    // 2. UI: Mostrar carga y ocultar men√∫s
    closeModals();
    document.getElementById('main-menu').style.display = 'none';
    // Tambi√©n ocultamos el modal de Game Over si venimos de un "Reintentar"
    const gameOverOverlay = document.getElementById('game-over-overlay');
    if (gameOverOverlay) gameOverOverlay.style.display = 'none';

    const loadingMsg = document.getElementById('loading-msg');
    if (loadingMsg) loadingMsg.style.display = 'flex';

    // 3. Descargar los 6 Pok√©mon
    await Promise.all([
        fetchGameData(),
        preloadBerries()
    ]);

    if (pokemonData.length < 6) {
        alert("Error loading Pok√©mon data.");
        resetToMenu();
        return;
    }

    // 4. Iniciar juego
    if (loadingMsg) loadingMsg.style.display = 'none';
    document.getElementById('game-screen').style.display = 'flex';
    
    // IMPORTANTE: Asegurarse de que el contador visual sea 0
    score = 0;
    if (scoreEl) scoreEl.innerText = "0";

    initBoard(); 
    
    if (!gameInitialized) {
        gameInitialized = true;
        requestAnimationFrame(renderLoop);
        // Iniciamos el chequeo de inactividad si no estaba
        if (typeof checkIdleTime === 'function') {
            setInterval(checkIdleTime, 1000);
        }
    }
}

function updateBackground(region) {
    const body = document.body;
    // Eliminamos cualquier clase de fondo previa
    body.className = body.className.replace(/\bbg-\S+/g, '');
    
    // A√±adimos la nueva clase seg√∫n la regi√≥n
    const bgClass = `bg-${region}`;
    body.classList.add(bgClass);
}

// Configuraci√≥n de entrada y prevenci√≥n de scroll
canvas.style.touchAction = 'none';
canvas.style.userSelect = 'none';
const BERRY_TYPES = ['CHERI', 'CHESTO', 'PECHA', 'ORAN', 'RAWST', 'SITRUS', 'ASPEAR', 'LUM'];
const BERRY_SPRITES = {}
const BERRY_LIST = {
    'CHERI': 'cheri-berry',
    'CHESTO': 'chesto-berry',
    'PECHA': 'pecha-berry',
    'ORAN': 'oran-berry',
    'RAWST': 'rawst-berry',
    'SITRUS': 'sitrus-berry',
    'ASPEAR': 'aspear-berry',
    'LUM': 'lum-berry'
};

let allPokemonList = [];
function playDittoCry() {
    if (!isMuted) {
        DITTO_CRY.currentTime = 0;
        DITTO_CRY.play().catch(() => {});
    }
}
function openRegionMenu() {
    // Primero cerramos cualquier otro modal abierto por seguridad
    closeModals();
    
    const regionModal = document.getElementById('region-modal');
    if (regionModal) {
        regionModal.style.display = 'flex';
    } else {
        console.error("Error: No se encontr√≥ el elemento 'region-modal' en el HTML.");
    }
}
function activateSitrusTimer() {
    const timerEl = document.getElementById('multiplier-timer');
    const countEl = document.getElementById('timer-count');
    const statusEl = document.getElementById('status');
    
    // 1. Show the timer and update state
    scoreMultiplier = 2;
    timerEl.style.display = 'block';
    statusEl.innerText = "‚ú® x2 POINTS ACTIVE! ‚ú®";
    
    let timeLeft = 60;
    countEl.innerText = timeLeft;

    // 2. Clear any old timer (if you get two berries in a row)
    if (multiplierInterval) clearInterval(multiplierInterval);

    // 3. Start the countdown
    multiplierInterval = setInterval(() => {
        timeLeft--;
        countEl.innerText = timeLeft;

        // 4. When time runs out
        if (timeLeft <= 0) {
            clearInterval(multiplierInterval);
            scoreMultiplier = 1;
            timerEl.style.display = 'none';
            statusEl.innerText = "SWIPE TO MATCH";
        }
    }, 1000);
}

// Add this to your startGame or an init function to preload them
async function preloadBerries() {
    // Si ya est√°n cargadas, no repetimos el proceso
    if (Object.keys(BERRY_SPRITES).length === BERRY_TYPES.length) return;

    for (const [key, fileName] of Object.entries(BERRY_LIST)) {
        if (BERRY_SPRITES[key]) continue; // Saltar si ya existe
        
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/${fileName}.png`;
        await new Promise(r => {
            img.onload = r;
            img.onerror = () => {
                console.warn(`Error loading berry: ${fileName}`);
                r(); // Continuamos aunque falle una
            };
        });
        BERRY_SPRITES[key] = img;
    }
}
const COLORS = ['red', 'blue', 'pink', 'orange', 'green', 'yellow'];
const FORM_OVERRIDES = {
    964: 10256, // Palafin Zero -> Palafin Hero
    774: 10130, // Minior Meteor -> Minior Core (Red)
    888: 10188, // Zacian -> Zacian Crowned
    889: 10189  // Zamazenta -> Zamazenta Crowned
};

function getRandomPokemonId() {
    // Elegimos un Pok√©mon que ya est√° en pokemonData
    if (pokemonData.length === 0) return 0; // fallback si todav√≠a no carg√≥ nada
    const keys = Object.keys(pokemonData); // los IDs cargados
    const randKey = keys[Math.floor(Math.random() * keys.length)];
    return parseInt(randKey);
}
function createTile(r, c, allowSound = false) {
    // IMPORTANTE: Elegimos un √≠ndice de 0 a 5 (los 6 Pok√©mon descargados de la regi√≥n)
    let typeIndex = Math.floor(Math.random() * pokemonData.length);

    const dittoCount = board.flat().filter(t => t && t.isDitto).length;
    const isBerry = Math.random() < 0.05; 
    const isDitto = !isBerry && dittoCount === 0 && Math.random() < DITTO_CHANCE;
    const isShiny = !isBerry && Math.floor(Math.random() * SHINY_CHANCE) === 0;

    return { 
        // Usamos el typeIndex para saber qu√© Pok√©mon de pokemonData dibujar
        id: isDitto ? -1 : typeIndex, 
        isDitto,
        isShiny, 
        isBerry,
        berryType: isBerry ? BERRY_TYPES[Math.floor(Math.random() * BERRY_TYPES.length)] : null,
        xOffset: 0, 
        yOffset: 0, 
        isMatch: false, 
        scale: 1, 
        rotation: 0,
        hasSpawned: false
    };
}

function createLumTimer() {
    if (document.getElementById('lum-timer')) return; // no duplicar

    const lumEl = document.createElement('div');
    lumEl.id = 'lum-timer';
    lumEl.style.position = 'absolute';
    lumEl.style.top = '10px';
    lumEl.style.right = '10px';
    lumEl.style.padding = '10px';
    lumEl.style.background = 'rgba(0,0,0,0.4)';
    lumEl.style.borderRadius = '8px';
    lumEl.style.color = 'white';
    lumEl.style.fontFamily = 'monospace';
    lumEl.style.fontWeight = 'bold';
    lumEl.style.zIndex = 9999;
    lumEl.innerHTML = '‚ú®INCREASED SHINY BOOST: <span id="lum-count">30</span>s‚ú®';
    lumEl.style.display = 'none';
    document.body.appendChild(lumEl);
}

// Activar Lum Berry
function activateLumBerry() {
    const lumEl = document.getElementById('lum-timer');
    const countEl = document.getElementById('lum-count');

    SHINY_CHANCE = 5; 
    lumActive = true;

    // Mostrar el recuadro
    lumEl.style.display = 'block';
    
    if (typeof statusEl !== 'undefined') {
        statusEl.innerText = '‚ú® SHINY BOOST ACTIVE! ‚ú®';
        statusEl.classList.add('shiny-alert');
    }

    let timeLeft = 10;
    countEl.innerText = timeLeft;

    if (lumInterval) clearInterval(lumInterval);

    lumInterval = setInterval(() => {
        timeLeft--;
        countEl.innerText = timeLeft;

        // Feedback visual de urgencia en el recuadro
        if (timeLeft <= 3) {
            lumEl.style.borderColor = (timeLeft % 2 === 0) ? "#ef4444" : "#94a3b8";
            lumEl.style.color = (timeLeft % 2 === 0) ? "#ef4444" : "#e2e8f0";
        }

        if (timeLeft <= 0) {
            clearInterval(lumInterval);
            lumInterval = null;
            SHINY_CHANCE = 100;
            lumActive = false;
            
            // Ocultar y resetear estilos
            lumEl.style.display = 'none';
            lumEl.style.borderColor = "#94a3b8";
            lumEl.style.color = "#e2e8f0";
            
            if (typeof statusEl !== 'undefined') {
                statusEl.classList.remove('shiny-alert');
                updateStatusText();
            }
        }
    }, 1000);
}
async function triggerBerryAbility(berry, r, c) {
    let tilesToDestroy = [];

    switch (berry.berryType) {
        case 'CHERI': // Column
            for (let i = 0; i < GRID_SIZE; i++) tilesToDestroy.push({r: i, c: c});
            break;
        case 'CHESTO': // Row
            for (let j = 0; j < GRID_SIZE; j++) tilesToDestroy.push({r: r, c: j});
            break;
        case 'PECHA': // All of same color
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j].id === berry.id) tilesToDestroy.push({r: i, c: j});
                }
            }
            break;
        case 'ORAN': // 3x3 Square
            for (let i = r - 1; i <= r + 1; i++) {
                for (let j = c - 1; j <= c + 1; j++) {
                    if (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE) tilesToDestroy.push({r: i, c: j});
                }
            }
            break;
        case 'RAWST': // Diagonals (X shape)
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.abs(r - i) === Math.abs(c - j)) tilesToDestroy.push({r: i, c: j});
                }
            }
            break;
        case 'SITRUS': // Double Points
    scoreMultiplier = 2;
    
    // UI Elements
    const timerEl = document.getElementById('multiplier-timer');
    const countEl = document.getElementById('timer-count');
    
    statusEl.innerText = '‚ú® 2X POINTS ACTIVE! ‚ú®';
    statusEl.classList.add('shiny-alert');
    timerEl.style.display = 'block';
    
    let timeLeft = 60;
    countEl.innerText = timeLeft;

    // Clear existing timer if one is already running (re-triggering a berry)
    if (multiplierInterval) clearInterval(multiplierInterval);

    multiplierInterval = setInterval(() => {
        timeLeft--;
        countEl.innerText = timeLeft;

        if (timeLeft <= 0) {
            clearInterval(multiplierInterval);
            scoreMultiplier = 1;
            timerEl.style.display = 'none';
            statusEl.classList.remove('shiny-alert');
            updateStatusText();
        }
    }, 1000);
    break;
    }

    if (tilesToDestroy.length > 0) {
        tilesToDestroy.forEach(pos => {
            const t = board[pos.r][pos.c];
            if (!t.isMatch) {
                t.isMatch = true;
                if (t.isShiny) captureShiny(t.id);
            }
        });
        // Increase score based on extra tiles destroyed
        score += tilesToDestroy.length * 50 * scoreMultiplier;
    }
}
function activateBerry(berry, x, y) {
    switch (berry.ability) {
        case 'CHERI': // Column
            for (let i = 0; i < gridHeight; i++) destroyTile(x, i);
            break;

        case 'CHESTO': // Row
            for (let j = 0; j < gridWidth; j++) destroyTile(j, y);
            break;

        case 'PECHA': // Clear same color
            allTiles.forEach(tile => {
                if (tile.color === berry.color) destroyTile(tile.x, tile.y);
            });
            break;

        case 'ORAN': // 3x3 Square
            for (let i = x - 1; i <= x + 1; i++) {
                for (let j = y - 1; j <= y + 1; j++) {
                    if (isValidCoords(i, j)) destroyTile(i, j);
                }
            }
            break;

        case 'RAWST': // Diagonals
            allTiles.forEach(tile => {
                if (Math.abs(tile.x - x) === Math.abs(tile.y - y)) {
                    destroyTile(tile.x, tile.y);
                }
            });
            break;

        case 'SITRUS': // Double score
            scoreMultiplier = 2;
            setTimeout(() => { scoreMultiplier = 1; }, 60000);
            break;
    }
}
function updateStatusText() {
    if (isShinyOnBoard()) {
        statusEl.innerText = '‚ú® SHINY SPAWNED! ‚ú®';
        statusEl.classList.add('shiny-alert'); // opcional animaci√≥n colores
    } else {
        statusEl.innerText = 'SWIPE TO MATCH';
        statusEl.classList.remove('shiny-alert');
    }
}
// --- SISTEMA DE GUARDADO Y CONTINUACI√ìN ---

function checkSaveFile() {
    const save = localStorage.getItem('shinyMatchSave');
    const continueBtn = document.getElementById('continue-btn');
    if (continueBtn) continueBtn.style.display = save ? 'flex' : 'none';
}
function openWho() {
    whoGrid.innerHTML = "";

    pokemonData.forEach(p => {
        const item = document.createElement('div');
        item.className = 'who-item';

        const img = document.createElement('img');
        img.src = p.images.normal.src;
        img.style.width = "64px";
        img.style.imageRendering = "pixelated";

        const name = document.createElement('div');
        name.className = 'who-name';
        name.textContent = p.name;

        item.appendChild(img);
        item.appendChild(name);
        whoGrid.appendChild(item);
    });

    whoModal.style.display = 'flex';
}
function saveGameState() {
    if (gameOver || pokemonData.length === 0) return;

    const gameState = {
        // Guardamos el tablero de forma limpia
        board: board.map(row => row.map(tile => ({
            id: tile.id,
            r: tile.r,
            c: tile.c,
            isShiny: tile.isShiny,
            isBerry: tile.isBerry || false,
            berryType: tile.berryType || null, // Guardamos 'SITRUS', 'ORAN', etc.
            isDitto: tile.isDitto || false
        }))),
        score: score,
        pokemonData: pokemonData.map(p => ({
            id: p.id,
            name: p.name,
            normalSrc: p.images.normal.src,
            shinySrc: p.images.shiny.src,
            cry: p.cry
        })),
        pokemonColors: pokemonColors,
        shinyTrackerHTML: shinyListEl.innerHTML
    };

    localStorage.setItem('shinyMatchSave', JSON.stringify(gameState));
    checkSaveFile();
}

function quitAndSave() {
    saveGameState();
    resetToMenu();
}

function getEffectiveId(id) {
    return FORM_OVERRIDES[id] || id;
}

async function continueGame() {
    const rawData = localStorage.getItem('shinyMatchSave');
    if (!rawData) return;
    const savedData = JSON.parse(rawData);

    mainMenu.style.display = 'none';
    gameScreen.style.display = 'flex';
    loadingEl.style.display = 'flex';

    // üéµ Iniciar m√∫sica
    playRandomMusic();

    // üî¢ Restaurar datos simples
    score = savedData.score;
    scoreEl.innerText = score;
    pokemonColors = savedData.pokemonColors;
    shinyListEl.innerHTML = savedData.shinyTrackerHTML || "";

    // üîπ IMPORTANTE: calcular TILE_SIZE ANTES de usarlo
    resize();

    // 1Ô∏è‚É£ Recargar los sprites de los Pok√©mon
    pokemonData = [];
    for (const p of savedData.pokemonData) {
        const normal = new Image();
        const shiny = new Image();
        normal.crossOrigin = "anonymous";
        shiny.crossOrigin = "anonymous";
        normal.src = p.normalSrc;
        shiny.src = p.shinySrc;

        await Promise.all([
            new Promise(r => normal.onload = r),
            new Promise(r => shiny.onload = r)
        ]);

        pokemonData.push({
            id: p.id,
            name: p.name,
            images: { normal, shiny },
            cry: p.cry
        });
    }

    // 2Ô∏è‚É£ Pre-cargar Berries
    if (typeof preloadBerries === 'function') {
        await preloadBerries();
    }

    // 3Ô∏è‚É£ Reconstruir el tablero (YA con TILE_SIZE v√°lido)
    board = savedData.board.map((row, r) =>
        row.map((tileData, c) => {
            const tile = {
                ...tileData,
                r,
                c,
                xOffset: 0,
                yOffset: 0,
                scale: 1,
                rotation: 0,
                targetRotation: 0
            };

            // Asignar imagen correcta
            if (tile.isBerry && tile.berryType) {
                tile.image = BERRY_SPRITES[tile.berryType];
            } else if (tile.isDitto) {
                tile.image = DITTO_IMAGE;
            } else {
                const pInfo = pokemonData[tile.id];
                if (pInfo) {
                    tile.image = tile.isShiny
                        ? pInfo.images.shiny
                        : pInfo.images.normal;
                }
            }

            return tile;
        })
    );

    loadingEl.style.display = 'none';

    // 4Ô∏è‚É£ Arrancar el loop solo una vez
    if (!gameInitialized) {
        gameInitialized = true;
        requestAnimationFrame(renderLoop);
        setInterval(checkIdleTime, 1000);
    }
}

// --- L√ìGICA DEL JUEGO ---

async function fetchGameData() {
    try {
        pokemonData = [];
        pokemonColors = [];
        const selectedIds = new Set();

        // Usar currentRegionIds (la que definimos en selectRegion)
        const idsToUse = (typeof currentRegionIds !== 'undefined') ? currentRegionIds : [];
        
        // Filtrar los que a√∫n no son shinies en la Pok√©dex global
        const missingShinyIds = idsToUse.filter(id => !caughtShinies[id]);

        while (selectedIds.size < 6) {
            let id;
            // Prioridad a los que no tenemos (70% de probabilidad)
            if (missingShinyIds.length > 0 && Math.random() < 0.7) {
                const randomIndex = Math.floor(Math.random() * missingShinyIds.length);
                id = missingShinyIds.splice(randomIndex, 1)[0];
            } else {
                id = idsToUse[Math.floor(Math.random() * idsToUse.length)];
            }
            selectedIds.add(id);
        }

        const idArray = Array.from(selectedIds);

        for (let i = 0; i < 6; i++) {
            let fetchId = getEffectiveId(idArray[i]);
            const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${fetchId}`);
            const data = await res.json();
            
            const normal = new Image();
            const shiny = new Image();
            normal.crossOrigin = "anonymous";
            shiny.crossOrigin = "anonymous";
            
            // --- CAMBIO AQU√ç: Volvemos a los sprites frontales est√°ndar ---
            // Usamos sprites.front_default para el look cl√°sico de p√≠xel
            normal.src = data.sprites.front_default;
            shiny.src = data.sprites.front_shiny;
            
            await Promise.all([
                new Promise(r => normal.onload = r), 
                new Promise(r => shiny.onload = r)
            ]);

            let rawName = data.name.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('-');
            const cleanName = rawName.charAt(0).toUpperCase() + rawName.slice(1);

            pokemonData.push({ 
                name: cleanName, 
                images: { normal, shiny }, 
                cry: data.cries ? data.cries.latest : null, 
                id: data.id 
            });

            pokemonColors.push(colors[i]);
        }
    } catch (e) { 
        console.error("Error cr√≠tico en fetchGameData:", e);
    }
}

function initBoard() {
  resize();
  ensurePlayableBoard();
  initMusicPlaylist();
  playRandomMusic(); // se ejecuta al cargar el tablero
  lastMoveTime = Date.now();
  if (isShinyOnBoard()) playSparkle();
}


function stopMusic() {
  bgAudio.pause();
  bgAudio.currentTime = 0; // opcional: reinicia para que empiece desde el principio la pr√≥xima vez
}

function ensurePlayableBoard() {
    let possible = false;
    while (!possible) {
        for (let r = 0; r < GRID_SIZE; r++) {
            board[r] = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                board[r][c] = createTile(Math.floor(Math.random() * 6), false);
            }
        }
        if (findMatches().length === 0 && hasAnyMove()) possible = true;
    }
}


// --- RENDERIZADO Y RESPONSIVIDAD ---

function resize() {
    const padding = 20;
    const availableWidth = window.innerWidth - padding;
    const availableHeight = window.innerHeight * 0.6;

    const size = Math.min(availableWidth, availableHeight, 500);

    const dpr = window.devicePixelRatio || 1;
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    
    ctx.setTransform(1, 0, 0, 1, 0, 0); // resetear transform
    ctx.scale(dpr, dpr);

    TILE_SIZE = size / GRID_SIZE;
}

function renderLoop() {
    
    if (gameScreen.style.display === 'none') { 
        updateMusicState(); // m√∫sica se para si el tablero no est√°
        requestAnimationFrame(renderLoop); 
        return; 
    }

    // Limpiar canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);


    // Dibujar piezas
for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
        const tile = board[r][c];

        // Saltar piezas eliminadas
        if (tile.isMatch && tile.scale <= 0) continue;

        const drawX = c * TILE_SIZE + tile.xOffset;
        const drawY = r * TILE_SIZE + tile.yOffset;
        const currentScale = tile.scale !== undefined ? tile.scale : 1;
        const displaySize = TILE_SIZE * currentScale * 0.9;
        
        // --- NUEVA VARIABLE PARA EL REDONDEO ---
        const cornerRadius = 12; 

        // 1. DIBUJAR FONDO DE LA PIEZA (CON BORDES REDONDEADOS)
        ctx.beginPath();
        if (tile.isDitto) {
            const hue = (Date.now() / 15) % 360;
            const gradient = ctx.createLinearGradient(drawX, drawY, drawX + TILE_SIZE, drawY + TILE_SIZE);
            gradient.addColorStop(0, `hsl(${hue}, 80%, 60%)`);
            gradient.addColorStop(1, `hsl(${(hue + 60) % 360}, 80%, 60%)`);
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = pokemonColors[tile.id] || "#334155";
        }
        
        ctx.globalAlpha = 1.0;
        // Reemplazamos fillRect por roundRect
        ctx.roundRect(drawX + 2, drawY + 2, TILE_SIZE - 4, TILE_SIZE - 4, cornerRadius);
        ctx.fill();

        // 2. BORDE SHINY (CON BORDES REDONDEADOS)
        if(tile.isShiny){
            ctx.beginPath(); // Reset para el nuevo camino
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 3;
            // Reemplazamos strokeRect por roundRect
            ctx.roundRect(drawX + 4, drawY + 4, TILE_SIZE - 8, TILE_SIZE - 8, cornerRadius - 2);
            ctx.stroke();
        }

        // 3. L√ìGICA DE ROTACI√ìN IDLE (Sin cambios)
        if(tile === idleRotatingTile && tile.targetRotation != null){
            const rotationSpeed = 0.1;
            if(tile.rotation < tile.targetRotation) tile.rotation += rotationSpeed;
            else {
                tile.rotation = 0;
                tile.targetRotation = null;
                idleRotatingTile = null;
            }
        }

        // 4. DIBUJAR CONTENIDO (DITTO, POKEMON O BAYA)
        ctx.save();
        ctx.translate(drawX + TILE_SIZE / 2, drawY + TILE_SIZE / 2);
        ctx.rotate(tile.rotation || 0);

        if (tile.isBerry) {
            ctx.beginPath();
            ctx.arc(0, 0, displaySize / 2.5, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.fill();

            const berryImg = BERRY_SPRITES[tile.berryType];
            if (berryImg) {
                ctx.drawImage(berryImg, -displaySize/2.5, -displaySize/2.5, displaySize/1.25, displaySize/1.25);
            }
        } else if (tile.isDitto) {
            // Renderizado de Ditto (Nota: es mejor usar im√°genes pre-cargadas para evitar parpadeos)
            const dittoImg = new Image();
            dittoImg.src = tile.isShiny 
                ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/132.png`
                : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png`;
            
            ctx.drawImage(dittoImg, -displaySize/2, -displaySize/2, displaySize, displaySize);
        } else {
            const pData = pokemonData[tile.id];
            if (pData && pData.images) {
                const img = tile.isShiny ? pData.images.shiny : pData.images.normal;
                if (img.complete) {
                    ctx.drawImage(img, -displaySize/2, -displaySize/2, displaySize, displaySize);
                }
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, displaySize/4, 0, Math.PI*2);
                ctx.fillStyle = "rgba(255,255,255,0.5)";
                ctx.fill();
            }
        }
        ctx.restore();

            // 5. DESTELLOS SHINY ALEATORIOS
            if(tile.isShiny && Math.random() < 0.05){
                spawnSparkle({ ...tile, r, c });
            }
        }
    }

    // Dibujar part√≠culas de destellos
    for(let i = sparkles.length - 1; i >= 0; i--){
        const s = sparkles[i];
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
        ctx.fill();
        s.alpha -= s.decay;
        if(s.alpha <= 0) sparkles.splice(i, 1);
    }

    updateStatusText();
    requestAnimationFrame(renderLoop);
}


// --- INTERACCI√ìN ---

canvas.addEventListener('pointerdown', e => { 
    if (isAnimating || gameOver) return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    
    const rect = canvas.getBoundingClientRect();
    startX = e.clientX; startY = e.clientY;
    
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    // Guardamos la posici√≥n inicial de la celda
    canvas.dataset.startR = Math.floor(clickY / (rect.height / GRID_SIZE));
    canvas.dataset.startC = Math.floor(clickX / (rect.width / GRID_SIZE));
    board.flat().forEach(tile => tile.rotation = 0);
lastMoveTime = Date.now();
});

canvas.addEventListener('pointerup', e => {
    if (isAnimating || gameOver || startX === null) return;
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    const threshold = 30; // Sensibilidad del swipe
    
    const r = parseInt(canvas.dataset.startR);
    const c = parseInt(canvas.dataset.startC);
    
    if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
        let dir = null;
        if (Math.abs(dx) > Math.abs(dy)) {
            if (Math.abs(dx) > threshold) dir = dx > 0 ? 'right' : 'left';
        } else {
            if (Math.abs(dy) > threshold) dir = dy > 0 ? 'down' : 'up';
        }
        if (dir) moveTile(r, c, dir);
    }
    startX = startY = null;
});

// --- L√ìGICA DE MOVIMIENTO Y ANIMACI√ìN ---

async function moveTile(r, c, dir) {
    let tr = r, tc = c;
    if (dir === 'up') tr--; else if (dir === 'down') tr++; 
    else if (dir === 'left') tc--; else if (dir === 'right') tc++;
    
    if (tr >= 0 && tr < GRID_SIZE && tc >= 0 && tc < GRID_SIZE) {
        isAnimating = true;
        await animateSlide(r, c, tr, tc);
        
        // SWAP THE ENTIRE OBJECT
        const temp = board[r][c];
        board[r][c] = board[tr][tc];
        board[tr][tc] = temp;

        // Only process if a REAL match-3 was made
        if (findMatches().length > 0) {
            await processMatches();
            saveGameState();
            if (!hasAnyMove()) endGame();
        } else {
            // Undo: Swap back the entire objects
            await animateSlide(r, c, tr, tc); 
            const swapBack = board[tr][tc];
            board[tr][tc] = board[r][c];
            board[r][c] = swapBack;
        }
        isAnimating = false;
    }
}

async function animateSlide(r1, c1, r2, c2) {
    const duration = 200; const startTime = Date.now();
    const t1 = board[r1][c1]; const t2 = board[r2][c2];
    return new Promise(resolve => {
        function anim() {
            const progress = Math.min((Date.now() - startTime) / duration, 1);
            t1.xOffset = (c2 - c1) * TILE_SIZE * progress; 
            t1.yOffset = (r2 - r1) * TILE_SIZE * progress;
            t2.xOffset = (c1 - c2) * TILE_SIZE * progress; 
            t2.yOffset = (r1 - r2) * TILE_SIZE * progress;
            if (progress < 1) requestAnimationFrame(anim);
            else { t1.xOffset = t1.yOffset = t2.xOffset = t2.yOffset = 0; resolve(); }
        } anim();
    });
}

async function processMatches() {
    let matches = findMatches();
    let comboLevel = 0; 
    
    // Bloqueamos la interacci√≥n del usuario mientras ocurren las animaciones
    isProcessing = true;

    while (matches.length > 0) {
        comboLevel++;
        const comboMultiplier = Math.min(comboLevel, 5);
        
        let tilesToDestroy = new Set();
        
        // Variables para calcular el centro exacto del grupo de piezas
        let sumX = 0;
        let sumY = 0;
        let count = 0;

        // 1. Identificar matches y expandir si hay bayas
        matches.forEach(m => {
            const tile = board[m.r][m.c];
            if (!tile.isMatch) {
                tilesToDestroy.add(`${m.r},${m.c}`);

                if (tile.isBerry) {
                    if (tile.berryType === 'SITRUS') activateSitrusTimer();
                    const pattern = getBerryPattern(tile, m.r, m.c);
                    pattern.forEach(pos => {
                        const hitTile = board[pos.r][pos.c];
                        if (hitTile.isBerry && !tilesToDestroy.has(`${pos.r},${pos.c}`)) {
                             if (hitTile.berryType === 'SITRUS') activateSitrusTimer();
                        }
                        tilesToDestroy.add(`${pos.r},${pos.c}`);
                    });
                }
            }
        });

        // 2. Calcular el centro visual de la explosi√≥n para el fantasmita
        const rect = canvas.getBoundingClientRect();
        tilesToDestroy.forEach(posKey => {
            const [r, c] = posKey.split(',').map(Number);
            sumX += rect.left + (c * TILE_SIZE) + (TILE_SIZE / 2);
            sumY += rect.top + (r * TILE_SIZE) + (TILE_SIZE / 2);
            count++;
        });

        if (count > 0 && comboMultiplier > 1) {
            const avgX = sumX / count;
            const avgY = sumY / count;
            showComboText(comboMultiplier, avgX, avgY);
        }

        // 3. Procesar Tiles, Puntuaci√≥n y Capturas
        tilesToDestroy.forEach(posKey => {
            const [r, c] = posKey.split(',').map(Number);
            const tile = board[r][c];

            if (!tile.isMatch) {
                tile.isMatch = true; // Fundamental: marca como procesado
                
                let basePoints = tile.isShiny ? 200 : 100;
                // Aplicamos (Puntos Base * Multiplicador Baya) * Multiplicador Combo
                score += (basePoints * scoreMultiplier) * comboMultiplier;

                if (tile.isShiny) {
                    if (tile.isDitto) {
                        captureShiny(132, true);
                        if (!isMuted) playDittoCry();
                    } else {
                        captureShiny(tile.id);
                        const pData = pokemonData[tile.id];
                        if (pData.cry && !isMuted) {
                            const crySound = new Audio(pData.cry);
                            crySound.volume = 0.5;
                            crySound.play().catch(() => {});
                        }
                    }
                } else if (!isMuted && !tile.isBerry) {
                    POP_SOUND_SOFT.currentTime = 0;
                    POP_SOUND_SOFT.play().catch(() => {});
                }
            }
        });

        // Actualizar el HTML del score
        document.getElementById('score').innerText = score;

        // 4. Animaci√≥n de encogimiento
        await animateShrink(Array.from(tilesToDestroy).map(key => {
            const [r, c] = key.split(',').map(Number);
            return { r, c };
        }));

        // 5. Gravedad: mover piezas hacia abajo
        for (let c = 0; c < GRID_SIZE; c++) {
            let empty = 0;
            for (let r = GRID_SIZE - 1; r >= 0; r--) {
                if (board[r][c].isMatch) {
                    empty++;
                } else if (empty > 0) {
                    board[r + empty][c] = { ...board[r][c], yOffset: -empty * TILE_SIZE, isMatch: false, scale: 1 };
                    board[r][c] = { isMatch: true };
                }
            }
            // Crear nuevas piezas en la parte superior
            for (let r = 0; r < empty; r++) {
                board[r][c] = createTile(Math.floor(Math.random() * 6), true);
                board[r][c].yOffset = -empty * TILE_SIZE;
                if (board[r][c].isShiny) {
                    playSparkle();
                    board[r][c].hasSpawned = true;
                }
            }
        }

        // 6. Esperar a que las piezas caigan visualmente
        await animateFalling();
        
        // 7. Re-comprobar si la ca√≠da ha generado nuevos matches (Combo)
        matches = findMatches();
        updateStatusText();
    }

    // Reactivamos la interacci√≥n al terminar todo
    isProcessing = false;
}

// Funci√≥n auxiliar para el efecto visual
function showComboText(multiplier, x, y) {
    const ghost = document.createElement('div');
    ghost.className = 'combo-ghost';
    if (multiplier === 5) ghost.classList.add('max-ghost');
    
    ghost.innerText = `x${multiplier}`;
    
    // Un peque√±o offset aleatorio para que no salgan siempre id√©nticos
    const offX = (Math.random() - 0.5) * 30;
    const offY = (Math.random() - 0.5) * 30;
    
    ghost.style.left = `${x + offX}px`;
    ghost.style.top = `${y + offY}px`;
    
    document.body.appendChild(ghost);
    setTimeout(() => ghost.remove(), 1200);
}
// Funci√≥n para crear el elemento flotante x2, x3...
function showComboText(multiplier, x, y) {
    const ghost = document.createElement('div');
    ghost.className = 'combo-ghost';
    if (multiplier === 5) ghost.classList.add('max-ghost');
    
    ghost.innerText = `x${multiplier}`;
    
    // Posicionamos el fantasma en las coordenadas exactas del match
    // Sumamos un peque√±o ajuste aleatorio para que si hay varios combos se dispersen
    const randomOffsetX = (Math.random() - 0.5) * 30;
    const randomOffsetY = (Math.random() - 0.5) * 30;
    
    ghost.style.left = `${x + randomOffsetX}px`;
    ghost.style.top = `${y + randomOffsetY}px`;
    
    document.body.appendChild(ghost);
    
    setTimeout(() => ghost.remove(), 1200);
}

function showComboMultiplier(combo) {
    if (combo <= 1) return; // No mostramos "x1"
    
    const comboText = document.createElement('div');
    comboText.className = 'combo-multiplier';
    comboText.innerText = `x${combo}`;
    
    // Posiciona el texto cerca del centro del tablero o de donde ocurra el match
    // Puedes ajustar estas coordenadas para que aparezca m√°s arriba o en un lugar espec√≠fico
    comboText.style.left = `${canvas.width / 2}px`;
    comboText.style.top = `${canvas.height / 2}px`;
    
    document.body.appendChild(comboText);

    // Elimina el texto despu√©s de la animaci√≥n
    setTimeout(() => {
        comboText.remove();
    }, 1000); // Duraci√≥n de la animaci√≥n en CSS
}
/** * Helper function to calculate which coordinates a berry hits
 */
function getBerryPattern(berry, r, c) {
    let pattern = [];
    switch (berry.berryType) {
        case 'CHERI': // Column
            for (let i = 0; i < GRID_SIZE; i++) pattern.push({ r: i, c: c });
            break;
        case 'CHESTO': // Row
            for (let j = 0; j < GRID_SIZE; j++) pattern.push({ r: r, c: j });
            break;
        case 'PECHA': // Same Color
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j].id === berry.id) pattern.push({ r: i, c: j });
                }
            }
            break;
        case 'ORAN': // 3x3
            for (let i = r - 1; i <= r + 1; i++) {
                for (let j = c - 1; j <= c + 1; j++) {
                    if (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE) pattern.push({ r: i, c: j });
                }
            }
            break;
        case 'RAWST': // Diagonals
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.abs(r - i) === Math.abs(c - j)) pattern.push({ r: i, c: j });
                }
            }
            break;
        case 'SITRUS': // Double Points
            scoreMultiplier = 2;
            statusEl.innerText = '‚ú® x2 POINTS ACTIVE! ‚ú®';
            statusEl.classList.add('shiny-alert');
            setTimeout(() => {
                scoreMultiplier = 1;
                updateStatusText();
            }, 60000);
            break;
        case 'ASPEAR': // NUEVO: fila + columna
            for (let i = 0; i < GRID_SIZE; i++) pattern.push({ r: i, c: c }); // columna
            for (let j = 0; j < GRID_SIZE; j++) pattern.push({ r: r, c: j }); // fila
            break;
            case 'LUM': // Increase shiny chance
    activateLumBerry();
    break;
    }
    return pattern;
}


async function animateShrink(matches) {
    const duration = 250; const startTime = Date.now();
    return new Promise(resolve => {
        function anim() {
            const progress = Math.min((Date.now() - startTime) / duration, 1);
            matches.forEach(m => { 
                board[m.r][m.c].scale = 1 - progress; 
            });
            if (progress < 1) requestAnimationFrame(anim); else resolve();
        } anim();
    });
}

async function animateFalling() {
    const duration = 300; const startTime = Date.now();
    return new Promise(resolve => {
        function anim() {
            const progress = Math.min((Date.now() - startTime) / duration, 1);
            let stillMoving = false;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c].yOffset < 0) {
                        board[r][c].yOffset += (TILE_SIZE * 0.12);
                        if (board[r][c].yOffset > 0) board[r][c].yOffset = 0;
                        stillMoving = true;
                    }
                }
            }
            if (stillMoving) requestAnimationFrame(anim); else resolve();
        } anim();
    });
}

// --- UTILIDADES RESTANTES ---

function findMatches() {
    let matches = [];
    
    const areCompatible = (t1, t2) => {
        if (t1.isMatch || t2.isMatch) return false;
        if (t1.isDitto || t2.isDitto) return true; // Ditto matchea con todo
        return t1.id === t2.id;
    };

    // Horizontal
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE - 2; c++) {
            let t1 = board[r][c], t2 = board[r][c+1], t3 = board[r][c+2];
            
            // L√≥gica: Si t1 y t2 son compatibles, y t2 y t3 son compatibles...
            // Pero necesitamos asegurar que al menos uno NO sea Ditto para saber el color,
            // o que si todos son Ditto, cuenten como match.
            if (areCompatible(t1, t2) && areCompatible(t2, t3)) {
                // Caso especial: si hay Dittos, confirmar que los colores reales presentes coincidan
                let nonDittoTiles = [t1, t2, t3].filter(t => !t.isDitto);
                let colorsPresent = new Set(nonDittoTiles.map(t => t.id));
                
                if (colorsPresent.size <= 1) { // 0 colores (todo ditto) o 1 color dominante
                    if (!(t1.isBerry && t2.isBerry && t3.isBerry)) {
                        matches.push({r, c}, {r, c:c+1}, {r, c:c+2});
                    }
                }
            }
        }
    }
    
    // Vertical (misma l√≥gica aplicada)
    for (let c = 0; c < GRID_SIZE; c++) {
        for (let r = 0; r < GRID_SIZE - 2; r++) {
            let t1 = board[r][c], t2 = board[r+1][c], t3 = board[r+2][c];
            if (areCompatible(t1, t2) && areCompatible(t2, t3)) {
                let nonDittoTiles = [t1, t2, t3].filter(t => !t.isDitto);
                let colorsPresent = new Set(nonDittoTiles.map(t => t.id));
                if (colorsPresent.size <= 1) {
                    if (!(t1.isBerry && t2.isBerry && t3.isBerry)) {
                        matches.push({r, c}, {r:r+1, c}, {r:r+2, c});
                    }
                }
            }
        }
    }
    return matches;
}

function hasAnyMove() {
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            if (c < GRID_SIZE - 1 && checkPotential(r, c, r, c + 1)) return true;
            if (r < GRID_SIZE - 1 && checkPotential(r, c, r + 1, c)) return true;
        }
    }
    return false;
}

function checkPotential(r1, c1, r2, c2) {
    const t1 = board[r1][c1].id;
    const t2 = board[r2][c2].id;
    board[r1][c1].id = t2;
    board[r2][c2].id = t1;
    const matches = findMatches();
    board[r1][c1].id = t1;
    board[r2][c2].id = t2;
    return matches.length > 0;
}


function captureShiny(tileId, isDitto = false) {
    try {
        let pInfo;

        if (isDitto) {
            pInfo = { 
                id: 132, 
                name: 'Ditto', 
                images: { shiny: { src: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/132.png' } } 
            };
        } else {
            // IMPORTANTE: tileId debe ser el √≠ndice 0-5
            pInfo = pokemonData[tileId];
        }

        // Si por alguna raz√≥n no hay datos, salimos de la funci√≥n inmediatamente
        if (!pInfo || !pInfo.id) return;
        sessionShiniesCaught.add(pInfo.id);

        // Si llegamos a los 6 diferentes y a√∫n no hemos mostrado el aviso en ESTA partida
        if (sessionShiniesCaught.size === 6 && !hasShownSessionPopup) {
            showUltimateCollectorPopup();
            hasShownSessionPopup = true; // Bloquea el popup hasta que se reinicie el juego
        }

        // Aplicar el ID de forma especial (Palafin, Zacian, etc.)
        const finalId = FORM_OVERRIDES[pInfo.id] || pInfo.id;

        // Guardar en el almacenamiento persistente
        if (!caughtShinies[finalId]) { 
    caughtShinies[finalId] = pInfo.images.shiny.src; // Guardamos el link de la imagen
    localStorage.setItem('shinyDex', JSON.stringify(caughtShinies)); 
        }

        // Actualizar UI del tracker lateral
        const img = document.createElement('img'); 
        img.crossOrigin = "anonymous";
        img.src = pInfo.images.shiny.src; 
        img.className = 'shiny-icon';
        
        if (shinyListEl) shinyListEl.appendChild(img); 
        if (finalShinyListEl) finalShinyListEl.appendChild(img.cloneNode());
        
        updateDexCount();

    } catch (error) {
        console.error("Error en captureShiny:", error);
    }
}

function updateDexCount() {
    const countEl = document.getElementById('dex-count');
    if (countEl) {
        const total = Object.keys(caughtShinies).length;
        countEl.innerText = `Caught Shinies: ${total}`;
    }
}

function isShinyOnBoard() { return board.some(row => row.some(tile => tile.isShiny && !tile.isMatch)); }
function playSparkle() { if (!isMuted) { SHINY_SOUND.currentTime = 0; SHINY_SOUND.play().catch(()=>{}); } }
function resetToMenu() {
  resetSitrusEffect();
  stopMusic(); // <--- esto para la m√∫sica
  gameScreen.style.display = 'none';
  mainMenu.style.display = 'block';
  checkSaveFile();
}

function endGame() { gameOver = true; finalScoreEl.innerText = score; gameOverOverlay.style.display = 'flex'; localStorage.removeItem('shinyMatchSave'); checkSaveFile(); }
function resetSitrusEffect() {
    // Detiene el intervalo del cron√≥metro si existe
    if (typeof multiplierInterval !== 'undefined' && multiplierInterval) {
        clearInterval(multiplierInterval);
        multiplierInterval = null;
    }
    
    // Resetea el multiplicador a la normalidad
    scoreMultiplier = 1;
    
    // Limpieza de la interfaz (ajusta los IDs seg√∫n tu HTML)
    const timerEl = document.getElementById('multiplier-timer');
    const statusEl = document.getElementById('status');
    
    if (timerEl) timerEl.style.display = 'none';
    if (statusEl) {
        statusEl.classList.remove('shiny-alert');
        statusEl.innerText = "SWIPE TO MATCH";
    }
}
async function startGame() {
    resetSitrusEffect();
    resetSessionUI(); // <--- A√ëADIR ESTO AQU√ç para limpiar iconos visuales al empezar partida
    sessionShiniesCaught.clear();
    hasShownSessionPopup = false;
    
    mainMenu.style.display = 'none'; 
    gameOverOverlay.style.display = 'none'; 
    gameScreen.style.display = 'flex'; 
    loadingEl.style.display = 'flex';
    
    // Reset game state
    pokemonData = []; 
    pokemonColors = []; 
    sparkles = []; 
    score = 0; 
    scoreEl.innerText = "0"; 
    gameOver = false;
    
    // Load Berries AND Pokemon data simultaneously
    await Promise.all([fetchGameData(), preloadBerries()]);

    if (pokemonData.length > 0) {
        initBoard(); 
        loadingEl.style.display = 'none';
        if(!gameInitialized) { 
            gameInitialized = true; 
            requestAnimationFrame(renderLoop); 
            setInterval(checkIdleTime, 1000); 
        }
    } else { 
        alert("Error loading Pok√©mon."); 
        resetToMenu(); 
    }
}

function openDex() {
    if (!dexGrid) return;
    dexGrid.innerHTML = "";

    // 1. Definimos la lista de IDs a mostrar
    // Si estamos en una regi√≥n, mostramos esa lista. Si no, Nacional + Regionales.
    const ALL_IDS = (typeof currentGameIds !== 'undefined' && currentGameIds.length > 0) 
        ? currentGameIds 
        : [...Array.from({length: 1025}, (_, i) => i + 1), ...REGIONAL_IDS];

    ALL_IDS.forEach(id => {
        // 2. Determinar la etiqueta (N√∫mero o R-X)
        let label = id;
        if (id > 1025) {
            const rIndex = REGIONAL_IDS.indexOf(id);
            if (rIndex !== -1) {
                label = `R-${rIndex + 1}`;
            }
        }

        // 3. Verificar si est√° capturado (considerando formas especiales como Palafin/Zacian)
        const effectiveId = (typeof FORM_OVERRIDES !== 'undefined' && FORM_OVERRIDES[id]) || id;
        const caughtData = caughtShinies[effectiveId];

        // 4. Crear el elemento del slot
        const slot = document.createElement('div');
        slot.className = `dex-slot ${caughtData ? 'caught' : 'not-caught'}`;

        // 5. Crear el n√∫mero/etiqueta
        const numSpan = document.createElement('span');
        numSpan.className = 'dex-num';
        numSpan.innerText = label;

        // 6. Crear la imagen
        const img = document.createElement('img');
        img.className = 'dex-img';
        
        if (caughtData) {
            // Si es un string (URL) lo usamos, si no, generamos la URL oficial
            img.src = typeof caughtData === 'string' ? caughtData : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/${effectiveId}.png`;
        } else {
            // Silueta del normal
            img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;
        }

        slot.appendChild(numSpan);
        slot.appendChild(img);
        dexGrid.appendChild(slot);
    });

    if (dexModal) dexModal.style.display = 'flex';
    updateDexCount();
}
function resetSessionUI() {
    // 1. Iconos de la barra lateral (Game Screen)
    if (shinyListEl) shinyListEl.innerHTML = "";
    
    // 2. Iconos de la pantalla de Game Over (Modal final)
    if (finalShinyListEl) finalShinyListEl.innerHTML = "";
    
    // 3. Reset de puntos y estado
    score = 0;
    if (scoreEl) scoreEl.innerText = "0";
    if (statusEl) {
        statusEl.innerText = "SWIPE TO MATCH";
        statusEl.classList.remove('shiny-alert');
    }
}
function createDexSlot(id, regionalOrder) {
    const slot = document.createElement('div');
    slot.className = 'dex-slot';
    
    // Get the visual ID (Crowned/Hero/Core)
    const visualId = getEffectiveId(id);

    const numberTag = document.createElement('span');
    numberTag.className = 'dex-number';
    numberTag.innerText = regionalOrder ? `R-${regionalOrder}` : id;

    const img = document.createElement('img');
    img.className = 'dex-img';

    if (caughtShinies[id]) {
        // Use the Shiny Sprite of the Hero/Crowned form
        img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/${visualId}.png`;
    } else {
        // Silhouette: Use the normal sprite of the Hero/Crowned form
        img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${visualId}.png`;
        slot.classList.add('not-caught');
    }

    slot.appendChild(numberTag);
    slot.appendChild(img);
    return slot;
}

function closeModals() {
    dexModal.style.display = 'none';
    whoModal.style.display = 'none';
}
function toggleMute() {
  isMuted = !isMuted;
  muteBtn.innerText = isMuted ? 'üîá' : 'üîä';
  if (bgAudio) {
    if (isMuted) bgAudio.pause();
    else bgAudio.play().catch(() => {});
  }
}
/**
 * GESTI√ìN DE M√öSICA Y ESTADOS DE PANTALLA
 */

function updateMusicState() {
    // Si no hay objeto de audio, no hacemos nada
    if (!bgAudio) return;

    const isGameVisible = gameScreen && window.getComputedStyle(gameScreen).display !== 'none';
    
    // Si la pantalla de juego no es visible, o el juego termin√≥, paramos
    if (!isGameVisible || gameOver) {
        stopMusic();
    } else if (!isMuted && bgAudio.paused) {
        // Si vuelve a ser visible y no est√° silenciado, reanudar
        bgAudio.play().catch(() => {});
    }
}

// Inicializaci√≥n segura del Observer
// Esto detecta cuando cambias de "Pantalla Principal" a "Juego"
const observer = new MutationObserver(() => {
    updateMusicState();
});

if (gameScreen) {
    observer.observe(gameScreen, { 
        attributes: true, 
        attributeFilter: ['style'] 
    });
}

let lastSongIndex = -1;

function playRandomMusic() {
    if (isMuted) return;

    // Si no hay playlist o se termin√≥, barajamos de nuevo
    if (!shuffledPlaylist.length || currentSongIndex >= shuffledPlaylist.length) {
        shuffledPlaylist = shuffleArray(musicFiles);
        currentSongIndex = 0;
    }

    const nextSong = shuffledPlaylist[currentSongIndex];
    currentSongIndex++;

    // Detener audio anterior
    if (bgAudio) {
        bgAudio.pause();
        bgAudio.currentTime = 0;
    }

    bgAudio = new Audio(nextSong);
    bgAudio.loop = false;
    bgAudio.volume = 0.5;

    bgAudio.play().catch(() => {});

    // Cuando termina ‚Üí reproducir la siguiente
    bgAudio.onended = () => {
        if (!gameOver && !isMuted) {
            playRandomMusic();
        }
    };
}

function stopMusic() {
    if (bgAudio) {
        bgAudio.pause();
        bgAudio.currentTime = 0;
        bgAudio = null;
    }
}

/**
 * CONTINUAR PARTIDA (CORREGIDA)
 */
function continueBoard() {
    gameOverOverlay.style.display = 'none';
    gameScreen.style.display = 'flex';
    
    // REINICIAR M√öSICA al continuar si no hay una sonando
    if (!bgAudio && !isMuted) {
        playRandomMusic();
    }
    
    isAnimating = false;
    requestAnimationFrame(renderLoop);
}

/**
 * UTILIDADES VISUALES Y AYUDAS
 */

function spawnSparkle(tile) {
    const drawX = tile.c * TILE_SIZE + TILE_SIZE/2;
    const drawY = tile.r * TILE_SIZE + TILE_SIZE/2;
    sparkles.push({
        x: drawX + (Math.random()-0.5) * TILE_SIZE * 0.6,
        y: drawY + (Math.random()-0.5) * TILE_SIZE * 0.6,
        radius: Math.random() * 2 + 1,
        alpha: 1,
        decay: Math.random() * 0.03 + 0.01
    });
}

function findFirstHint() {
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            // Check Horizontal y Vertical para posibles movimientos
            if (c < GRID_SIZE - 1 && checkPotential(r, c, r, c + 1)) return board[r][c]; 
            if (r < GRID_SIZE - 1 && checkPotential(r, c, r + 1, c)) return board[r][c];
        }
    }
    return null;
}

function checkIdleTime() {
    const IDLE_THRESHOLD = 10000; // 10 segundos
    if ((Date.now() - lastMoveTime) < IDLE_THRESHOLD) {
        idleRotatingTile = null;
        return;
    }

    if (idleRotatingTile) return;

    const hintTile = findFirstHint();
    if (hintTile) {
        idleRotatingTile = hintTile;
        // Rotaci√≥n de 360 grados para llamar la atenci√≥n
        idleRotatingTile.targetRotation = idleRotatingTile.rotation + (2 * Math.PI);
    }
}

/**
 * MODALES Y GU√çAS
 */

function openBerryGuide() {
    const guideList = document.getElementById('berry-guide-list');
    if (!guideList) return;
    
    guideList.innerHTML = "";
    const descriptions = {
        'CHERI': 'Clears the entire COLUMN.',
        'CHESTO': 'Clears the entire ROW.',
        'PECHA': 'Clears ALL Pok√©mon of the same color.',
        'ORAN': 'Explodes in a 3x3 SQUARE area.',
        'RAWST': 'Clears tiles in an X-SHAPED diagonal.',
        'SITRUS': 'DOUBLE POINTS for 60 seconds!',
        'ASPEAR': 'Clears the entire ROW and COLUMN.',
        'LUM': 'Increases SHINY CHANCE for 10 seconds!'
    };

    BERRY_TYPES.forEach(type => {
        const row = document.createElement('div');
        row.className = 'berry-row';
        row.innerHTML = `
            <img src="${BERRY_SPRITES[type].src}" alt="${type}">
            <div class="berry-info">
                <h4>${type} BERRY</h4>
                <p>${descriptions[type]}</p>
            </div>
        `;
        guideList.appendChild(row);
    });
    document.getElementById('berry-modal').style.display = 'flex';
}

function closeModals() {
    const modals = ['dex-modal', 'who-modal', 'berry-modal', 'tutorial-modal', 'region-modal'];
    modals.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
    });
}

// Eventos globales
window.addEventListener('resize', resize);
window.addEventListener('load', checkSaveFile);

// Pausar m√∫sica si el usuario cambia de pesta√±a del navegador
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        if (bgAudio) bgAudio.pause();
    } else {
        updateMusicState();
    }
});

async function downloadScoreImage() {
    const canvasRef = document.createElement('canvas');
    const ctx = canvasRef.getContext('2d');
    canvasRef.width = 600;
    canvasRef.height = 450;

    // 1. Background: Parchment/Paper Aesthetic
    const gradient = ctx.createLinearGradient(0, 0, 600, 450);
    gradient.addColorStop(0, '#fdfcf0'); 
    gradient.addColorStop(1, '#f2eecb'); 
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 600, 450);

    // 2. Decorative Diploma Borders
    ctx.strokeStyle = '#c5a059'; 
    ctx.lineWidth = 15;
    ctx.strokeRect(10, 10, 580, 430);
    ctx.strokeStyle = '#5d4037';
    ctx.lineWidth = 2;
    ctx.strokeRect(25, 25, 550, 400);

    // 3. Header Text
    ctx.fillStyle = '#5d4037'; 
    ctx.textAlign = 'center';
    ctx.font = 'italic bold 24px Georgia, "Times New Roman", serif';
    ctx.fillText('This certifies that you have completed a', 300, 70);

    // 4. Main Title
    ctx.font = 'bold 50px Georgia, serif';
    ctx.fillText('SHINY MATCH', 300, 130);

    // 5. Score Section
    ctx.font = '20px Georgia, serif';
    ctx.fillText('With a record-breaking total score of:', 300, 180);
    ctx.fillStyle = '#8b6b23'; 
    ctx.font = 'bold 75px "Times New Roman", serif';
    ctx.fillText(score.toLocaleString(), 300, 260);

    // 6. Shiny Counter "Seal"
    const totalShinies = document.querySelectorAll('#final-shiny-list img').length;
    ctx.fillStyle = '#5d4037';
    ctx.font = 'italic bold 22px Georgia, serif';
    ctx.fillText(`Master of ${totalShinies} Shiny Discoveries`, 300, 310);

    // 7. Pokemon Icons (With Shiny Check and Shimmer)
    const iconSize = 65;
    const spacing = 80;
    const startX = 300 - ((spacing * 5 + iconSize) / 2);
    const startY = 330;

    for (let i = 0; i < 6; i++) {
        if (pokemonData[i]) {
            await new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                
                // CHECK IF SHINY: Verify if this ID exists in your caughtShinies global object
                const pId = pokemonData[i].id;
                const effectiveId = (typeof FORM_OVERRIDES !== 'undefined' && FORM_OVERRIDES[pId]) || pId;
                const isAlreadyCaughtShiny = !!caughtShinies[effectiveId];

                img.onload = () => {
                    const xPos = startX + (i * spacing);
                    const yPos = startY;

                    // If it's a shiny, draw a golden shimmer "glow" behind it
                    if (isAlreadyCaughtShiny) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
                        ctx.beginPath();
                        ctx.arc(xPos + iconSize/2, yPos + iconSize/2, 35, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add sparkle stars
                        ctx.fillStyle = '#fbbf24';
                        const drawStar = (cx, cy, spikes, outer, inner) => {
                            let rot = Math.PI/2*3, x = cx, y = cy, step = Math.PI/spikes;
                            ctx.beginPath(); ctx.moveTo(cx, cy - outer);
                            for(let j=0; j<spikes; j++){
                                x=cx+Math.cos(rot)*outer; y=cy+Math.sin(rot)*outer; ctx.lineTo(x,y); rot+=step;
                                x=cx+Math.cos(rot)*inner; y=cy+Math.sin(rot)*inner; ctx.lineTo(x,y); rot+=step;
                            }
                            ctx.lineTo(cx, cy-outer); ctx.closePath(); ctx.fill();
                        };
                        drawStar(xPos + 10, yPos + 10, 4, 5, 2);
                        drawStar(xPos + iconSize - 5, yPos + 15, 4, 4, 2);
                        ctx.restore();
                    }

                    // Draw the sprite (Shadow for diploma look)
                    ctx.shadowColor = "rgba(0,0,0,0.2)";
                    ctx.shadowBlur = 5;
                    ctx.drawImage(img, xPos, yPos, iconSize, iconSize);
                    ctx.shadowBlur = 0;
                    resolve();
                };
                img.onerror = resolve;

                // Set source to Shiny if caught, otherwise Normal
                img.src = isAlreadyCaughtShiny ? pokemonData[i].images.shiny.src : pokemonData[i].images.normal.src;
            });
        }
    }

    // 8. Footer Watermark
    ctx.font = '12px "Times New Roman", serif';
    ctx.fillStyle = 'rgba(93, 64, 55, 0.6)';
    ctx.fillText('play at: https://xoelpr03.github.io/pokejuegomatchAPP/', 300, 415);

    // 9. Download
    const dataUrl = canvasRef.toDataURL('image/png');
    const link = document.createElement('a');
    link.download = `ShinyMatch_Diploma_${score}.png`;
    link.href = dataUrl;
    link.click();
}
function showUltimateCollectorPopup() {
    const overlay = document.createElement('div');
    overlay.id = 'ultimate-popup';
    // Estilo en l√≠nea r√°pido para asegurar que se vea bien
    overlay.style = "position:fixed; inset:0; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; z-index:9999;";
    
    overlay.innerHTML = `
        <div style="background:#1e293b; border:3px solid #fbbf24; padding:30px; border-radius:15px; text-align:center; color:white; max-width:300px;">
            <div style="font-size:40px;">üèÜ</div>
            <h2 style="color:#fbbf24; margin:10px 0;">CONGRATS!</h2>
            <p>You've caught all 6 shinys on this board!</p>
            <button onclick="this.parentElement.parentElement.remove()" 
                    style="margin-top:15px; background:#fbbf24; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; font-weight:bold;">
                CONTINUE
            </button>
        </div>
    `;
    document.body.appendChild(overlay);
}
let shuffledPlaylist = [];
let currentSongIndex = 0;
let bgAudio = null;
function shuffleArray(array) {
    const arr = [...array]; // copia segura
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}
function initMusicPlaylist() {
    shuffledPlaylist = shuffleArray(musicFiles);
    currentSongIndex = 0;
}
function giveUp() {
    // Optional: Ask for confirmation so players don't click it by accident
    const confirmChoice = confirm("Are you sure you want to end this run?");
    
    if (confirmChoice) {
        // Stop the game loop and music
        gameOver = true;
        stopMusic();
        
        // Use your existing endGame logic to show the overlay and final score
        endGame();
    }
}
window.addEventListener('resize', () => { resize(); });
window.addEventListener('load', checkSaveFile);
</script>
</body>
</html>
