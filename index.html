<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shiny Match</title>
    <style>
        :root {
            --bg: #0f172a;
            --card-bg: rgba(255, 255, 255, 0.98);
            --text-main: #1e293b;
            --accent: #3b82f6;
            --success: #10b981;
            --danger: #ef4444;
            --shiny-gold: #fbbf24;
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: radial-gradient(circle at top, #1e293b 0%, #0f172a 100%);
            color: #f8fafc;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            height: 100vh;
            overflow: hidden;
        }

        /* --- MENU STYLES --- */
        .menu-card {
            background: var(--card-bg);
            width: 90%;
            max-width: 350px;
            padding: 30px 20px;
            border-radius: 24px;
            box-shadow: 0 20px 40px -10px rgba(0,0,0,0.5);
            text-align: center;
            color: var(--text-main);
            z-index: 100;
        }

        .menu-title {
            font-size: 28px; font-weight: 900; margin: 10px 0 5px 0; text-transform: uppercase;
            background: linear-gradient(135deg, #ef4444 0%, #3b82f6 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .btn-group { display: flex; flex-direction: column; gap: 12px; }

        .menu-btn {
            width: 100%; height: 50px; border-radius: 12px; font-size: 14px; font-weight: 800;
            cursor: pointer; border: none; text-transform: uppercase; transition: 0.2s;
            display: flex; align-items: center; justify-content: center; text-decoration: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mode-play { background: #3b82f6; color: white; font-size: 18px; }
        .mode-how { background: #f1f5f9; color: #475569; border: 2px solid #e2e8f0; }
        .mode-dex { background: #fbbf24; color: #78350f; }
        .exit-link-btn { background: #64748b; color: white; }

        .mute-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white; border: 1px solid rgba(255, 255, 255, 0.2);
            width: 40px; height: 40px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 18px; transition: 0.3s;
        }
        .mute-btn.active { background: var(--danger); border-color: transparent; }

        /* --- MODAL STYLES --- */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            color: var(--text-main);
            width: min(90vw, 520px);
            max-height: 80vh;
            padding: clamp(18px, 4vw, 30px);
            border-radius: 20px;
            text-align: center;
            overflow: hidden;
        }

        #dex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(56px, 1fr));
            gap: clamp(6px, 1.5vw, 10px);
            max-height: 45vh;
            overflow-y: auto;
            margin: 15px 0;
            padding: 10px;
            background: #f1f5f9;
            border-radius: 12px;
        }

        .dex-slot {
    position: relative; /* Para poder posicionar el n√∫mero dentro */
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid #ccc;
    padding: 5px;
}

.dex-number {
    font-size: 0.8rem;
    font-weight: bold;
    color: #555;
    margin-bottom: 2px;
}

.not-caught .dex-img {
    filter: brightness(0); /* Silueta negra si no est√° atrapado */
    opacity: 0.5;
}

        .dex-num {
            position: absolute;
            top: 2px;
            left: 3px;
            font-size: 8px;
            font-weight: 900;
            color: #cbd5e1;
        }

        /* --- GAME SCREEN --- */
        #game-screen { 
            display: none; 
            flex-direction: column;
            align-items: center;
            width: 95vw; 
            max-width: 500px; 
            max-height: 98vh;
            padding: 10px; 
            box-sizing: border-box;
            position: relative;
        }

        #game-over-overlay {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 24px;
            animation: fadeIn 0.3s ease;
            text-align: center;
            padding: 20px;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        #header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        #score-box { text-align: left; }
        #score-label { font-size: 10px; color: #94a3b8; font-weight: 800; }
        #score { font-size: 28px; font-weight: 900; color: #fbbf24; line-height: 1; }

        canvas {
    width: 100%;
    height: auto;
    max-width: 100%;
    max-height: 100%;
    background: #1e293b; 
    border: 4px solid #475569;
    border-radius: 18px; 
    image-rendering: pixelated;
    touch-action: none; 
    cursor: crosshair;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
}

        #shiny-tracker {
            margin-top: 10px;
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 8px;
            min-height: 50px;
            overflow-y: auto;
        }
        #shiny-label { font-size: 10px; color: #94a3b8; font-weight: 800; text-align: left; margin-bottom: 5px;}
        #shiny-list, #final-shiny-list { display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; }

        .shiny-icon { 
            width: 35px; 
            height: 35px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 8px; 
            image-rendering: pixelated; 
        }

        #status { font-size: 12px; color: #fbbf24; margin-top: 5px; font-weight: 800; height: 15px; text-transform: uppercase; }
        
        #loading-msg { 
            position: fixed; inset: 0; background: #0f172a; 
            display: none; align-items: center; justify-content: center; 
            z-index: 2000; font-weight: 900; letter-spacing: 2px;
        }

        .creator-credit {
            margin-top: 25px; font-size: 9px; font-weight: 800; text-transform: lowercase;
            letter-spacing: 2px; color: #94a3b8; opacity: 0.6; text-align: center;
            border-top: 1px solid #e2e8f0; padding-top: 12px; width: 180px; margin: 25px auto 0;
        }

        .shiny-alert { animation: rainbow 1.5s infinite; }
        @keyframes rainbow {
            0% { color: #f87171; } 25% { color: #facc15; } 50% { color: #34d399; } 75% { color: #60a5fa; } 100% { color: #f87171; }
        }

        #who-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
    max-height: 45vh;
    overflow-y: auto;
    margin: 15px 0;
    padding: 10px;
    background: #f1f5f9;
    border-radius: 12px;
}

.dex-img, .who-item img {
    width: clamp(40px, 12vw, 64px);
    height: clamp(40px, 12vw, 64px);
    image-rendering: crisp-edges;
    object-fit: contain;
}

.who-name {
    font-size: 10px;
    font-weight: 800;
    text-transform: uppercase;
    color: var(--accent);
    margin-top: 4px;
}

.quit-btn {
    background: rgba(255, 255, 255, 0.1);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 18px;
    transition: 0.3s;
    outline: none;
}

.quit-btn:hover {
    background: rgba(239, 68, 68, 0.25);
    border-color: rgba(239, 68, 68, 0.6);
    transform: scale(1.08);
}

.quit-btn:active {
    transform: scale(0.95);
}

#gameCanvas {
    touch-action: none; /* Esto es vital para que el swipe funcione en m√≥viles */
}
#berry-guide-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin: 15px 0;
    text-align: left;
    max-height: 50vh;
    overflow-y: auto;
    padding: 10px;
}

.berry-row {
    display: flex;
    align-items: center;
    gap: 15px;
    background: #f8fafc;
    padding: 10px;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
}

.berry-row img {
    width: 40px;
    height: 40px;
    image-rendering: pixelated;
}

.berry-info h4 {
    margin: 0;
    font-size: 14px;
    color: var(--text-main);
    text-transform: uppercase;
}

.berry-info p {
    margin: 2px 0 0 0;
    font-size: 11px;
    color: #64748b;
    font-weight: 600;
}

/* --- Multiplier Timer Styling --- */
#multiplier-timer {
    background: rgba(251, 191, 36, 0.15); /* Light gold transparency */
    border: 1px solid var(--shiny-gold);
    padding: 5px 15px;
    border-radius: 20px;
    margin-bottom: 10px;
    box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
    animation: pulse-glow 2s infinite ease-in-out;
}

#timer-count {
    font-variant-numeric: tabular-nums; /* Prevents text jumping when numbers change */
    color: #fff;
    text-shadow: 0 0 5px var(--shiny-gold);
}

@keyframes pulse-glow {
    0% { transform: scale(1); box-shadow: 0 0 10px rgba(251, 191, 36, 0.3); }
    50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(251, 191, 36, 0.5); }
    100% { transform: scale(1); box-shadow: 0 0 10px rgba(251, 191, 36, 0.3); }
}
.tutorial-body {
    text-align: left;
    max-height: 60vh;
    overflow-y: auto;
    padding: 15px;
    color: white;
}

.tutorial-body h3 {
    color: #f97316; /* Orange color to stand out */
    margin-bottom: 5px;
    font-size: 1.1em;
    text-transform: uppercase;
}

.tutorial-body p {
    font-size: 0.95em;
    line-height: 1.5;
    margin-bottom: 12px;
    color: #cbd5e1;
}

hr { 
    border: 0; 
    border-top: 1px solid #475569; 
    margin: 15px 0; 
}

/* Ensure buttons look consistent with your theme */
.close-btn {
    background: #22c55e;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    margin-top: 10px;
}

    </style>
</head>
<body>

    <div id="loading-msg">FETCHING POK√âMON...</div>

    <div id="dex-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="color: var(--shiny-gold); margin-top: 0;">‚ú® SHINY POK√âDEX ‚ú®</h3>
            <p id="dex-count" style="font-size: 12px; font-weight: 800; color: #64748b;"></p>
            <div id="dex-grid"></div>
            <button class="menu-btn exit-link-btn" onclick="closeModals()">CLOSE</button>
        </div>
    </div>

    <div id="berry-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="color: var(--success); margin-top: 0;">BERRY EFFECTS</h3>
        <div id="berry-guide-list">
            </div>
        <button class="menu-btn mode-play" onclick="closeModals()">GOT IT!</button>
    </div>
</div>

    <div id="main-menu" class="menu-card">
    <div style="font-size: 50px; margin-bottom: 10px;">‚ú®</div>
    <h1 class="menu-title">Shiny Match</h1>
    <p style="font-size: 11px; margin-bottom: 20px; font-weight: 600; color: #64748b;">SHINY ODDS: 1/100</p>
    <div class="btn-group">
        <button class="menu-btn mode-play" onclick="startGame()">Start Hunt</button>
        <button id="continue-btn" class="menu-btn mode-play" style="background: #10b981; display: none;" onclick="continueGame()">Continue Hunting</button>
        
        <button class="menu-btn" style="background: #6366f1;" onclick="openTutorial()">How to Play</button>
        
        <button class="menu-btn mode-dex" onclick="openDex()">Shiny Pokedex</button>
    </div>
    <div class="creator-credit">created by ŒæawsjŒ±ke</div>
</div>

    <div id="game-screen">
        <div id="game-over-overlay">
            <h2 style="color: var(--danger); font-size: 40px; margin-bottom: 5px; font-weight: 900;">GAME OVER</h2>
            <p style="font-size: 20px; font-weight: 800; margin-bottom: 10px;">SCORE: <span id="final-streak">0</span></p>
            
            <div id="game-over-shinies" style="margin-bottom: 20px;">
                <div style="font-size: 10px; color: #94a3b8; font-weight: 800; margin-bottom: 10px;">SHINIES COLLECTED</div>
                <div id="final-shiny-list"></div>
            </div>

            <div class="btn-group" style="width: 220px;">
                <button class="menu-btn mode-play" onclick="startGame()">Try Again</button>
                <button class="menu-btn exit-link-btn" onclick="resetToMenu()">Main Menu</button>
            </div>
        </div>

        <div id="header">
            <div id="score-box">
                <div id="score-label">SCORE</div>
                <div id="score">0</div>
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <div id="who-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="color: var(--accent); margin-top: 0;">Who's That Pok√©mon?</h3>
        <div id="who-grid"></div>
        <button class="menu-btn mode-play" onclick="closeModals()">BACK TO HUNT</button>
    </div>
</div>

<button class="menu-btn mode-how" style="width: 40px; height: 40px; border-radius: 50%; font-size: 18px; background: #10b981; color: white;" onclick="openBerryGuide()">üçí</button>
<button class="menu-btn mode-dex" style="width: 40px; height: 40px; border-radius: 50%; font-size: 18px;" onclick="openWho()">‚ùì</button>
                <button id="muteBtn" class="mute-btn" onclick="toggleMute()">üîä</button>
                <button class="quit-btn" onclick="quitAndSave()">‚úï</button>
        
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>
        <div id="multiplier-timer" style="display: none; font-size: 14px; font-weight: 900; color: #fbbf24; margin-bottom: 5px;">
        ‚ú® 2X POINTS: <span id="timer-count">60</span>s
    </div>
        <div id="status">SWIPE TO MATCH</div>

        <div id="shiny-tracker">
            <div id="shiny-label">SHINIES CAPTURED</div>
            <div id="shiny-list"></div>
        </div>
    </div>
    <div id="tutorial-modal" class="modal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 1000; align-items: center; justify-content: center; padding: 20px;">
    <div class="modal-content" style="background: #1e293b; border: 2px solid #475569; border-radius: 15px; width: 100%; max-width: 400px; padding: 20px; color: white;">
        <h2 style="color: #eab308; margin-top: 0; text-align: center;">üéÆ How To Play?</h2>
        
        <div style="max-height: 60vh; overflow-y: auto; text-align: left; font-size: 14px; line-height: 1.5;">
            <p><strong>‚ú® Catch Shinies:</strong> Swipe in any direction to match 3 or more Pok√©mon. Match a <b>Shiny</b> and it‚Äôs added to your permanent Dex!</p>

<p><strong>üåà Ditto:</strong> The ultimate wild card! It can match any color to help you complete lines.</p>

<p><strong>üçí Berries:</strong> Match them with Pok√©mon to trigger special powers, like clearing lines or doubling your points!</p>

<p><strong>üîÑ Idle Hints:</strong> Stuck? After 10 seconds of no moves, a piece will <b>rotate</b> to show you a valid match.</p>

        </div>

        <button class="menu-btn" style="background: #ef4444; width: 100%; margin-top: 15px;" onclick="closeModals()">Got it!</button>
    </div>
</div>

<script>
    const tutorialModal = document.getElementById('tutorial-modal');
    const DITTO_CHANCE = 0.01;
    const DITTO_IMAGE = new Image(); DITTO_IMAGE.src = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png';
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const statusEl = document.getElementById('status');
const loadingEl = document.getElementById('loading-msg');
const mainMenu = document.getElementById('main-menu');
const gameScreen = document.getElementById('game-screen');
const gameOverOverlay = document.getElementById('game-over-overlay');
const finalScoreEl = document.getElementById('final-streak');
const shinyListEl = document.getElementById('shiny-list');
const finalShinyListEl = document.getElementById('final-shiny-list');
const muteBtn = document.getElementById('muteBtn');
const whoModal = document.getElementById('who-modal');
const whoGrid = document.getElementById('who-grid');
const dexModal = document.getElementById('dex-modal');
const dexGrid = document.getElementById('dex-grid');
const dexCount = document.getElementById('dex-count');
let multiplierInterval = null;
const SHINY_SOUND = new Audio('https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3');
SHINY_SOUND.volume = 1;
const POP_SOUND_SOFT = new Audio('https://freesound.org/data/previews/411/411639_5121236-lq.mp3');
POP_SOUND_SOFT.volume = 0.7;
let scoreMultiplier = 1
let isMuted = false;
const GRID_SIZE = 7; 
const SHINY_CHANCE = 100;
let TILE_SIZE = 0;
let board = [];
let score = 0;
let isAnimating = false;
let gameOver = false;
let lastMoveTime = Date.now();
let gameInitialized = false;
let startX = null, startY = null;
let sparkles = [];
let pokemonData = [];
let pokemonColors = [];
let idleRotatingTile = null;
let allShiniesMessageShown = false;
const colors = ["#ef4444", "#f97316", "#eab308", "#22c55e", "#06b6d4", "#ec4899"];
const REGIONAL_IDS = [10091, 10092, 10100, 10101, 10102, 10103, 10104, 10105, 10106, 10107, 10108, 10109, 10110, 10111, 10112, 10113, 10114, 10115, 10161, 10162, 10163, 10164, 10165, 10166, 10167, 10168, 10169, 10170, 10171, 10172, 10173, 10174, 10175, 10176, 10177, 10179, 10180, 10229, 10230, 10231, 10232, 10233, 10234, 10235, 10236, 10237, 10238, 10239, 10240, 10241, 10242, 10243, 10244, 10250, 10253];
const DITTO_CRY = new Audio('https://raw.githubusercontent.com/PokeAPI/stock-pokemon-cries/master/cries/pokemon/latest/132.ogg');
DITTO_CRY.volume = 0.5; // Adjust volume as needed
let caughtShinies = JSON.parse(localStorage.getItem('shinyDex')) || {};

// Configuraci√≥n de entrada y prevenci√≥n de scroll
canvas.style.touchAction = 'none';
canvas.style.userSelect = 'none';
const BERRY_TYPES = ['CHERI', 'CHESTO', 'PECHA', 'ORAN', 'RAWST', 'SITRUS'];
const BERRY_SPRITES = {};
const BERRY_LIST = {
    'CHERI': 'cheri-berry',
    'CHESTO': 'chesto-berry',
    'PECHA': 'pecha-berry',
    'ORAN': 'oran-berry',
    'RAWST': 'rawst-berry',
    'SITRUS': 'sitrus-berry'
};
function playDittoCry() {
    if (!isMuted) {
        DITTO_CRY.currentTime = 0;
        DITTO_CRY.play().catch(() => {});
    }
}
function activateSitrusTimer() {
    const timerEl = document.getElementById('multiplier-timer');
    const countEl = document.getElementById('timer-count');
    const statusEl = document.getElementById('status');
    
    // 1. Show the timer and update state
    scoreMultiplier = 2;
    timerEl.style.display = 'block';
    statusEl.innerText = "‚ú® 2X POINTS ACTIVE! ‚ú®";
    
    let timeLeft = 60;
    countEl.innerText = timeLeft;

    // 2. Clear any old timer (if you get two berries in a row)
    if (multiplierInterval) clearInterval(multiplierInterval);

    // 3. Start the countdown
    multiplierInterval = setInterval(() => {
        timeLeft--;
        countEl.innerText = timeLeft;

        // 4. When time runs out
        if (timeLeft <= 0) {
            clearInterval(multiplierInterval);
            scoreMultiplier = 1;
            timerEl.style.display = 'none';
            statusEl.innerText = "SWIPE TO MATCH";
        }
    }, 1000);
}

// Add this to your startGame or an init function to preload them
async function preloadBerries() {
    for (const [key, fileName] of Object.entries(BERRY_LIST)) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/${fileName}.png`;
        await new Promise(r => img.onload = r);
        BERRY_SPRITES[key] = img;
    }
}
const COLORS = ['red', 'blue', 'pink', 'orange', 'green', 'yellow'];
const FORM_OVERRIDES = {
    964: 10256, // Palafin Zero -> Palafin Hero
    774: 10130, // Minior Meteor -> Minior Core (Red)
    888: 10188, // Zacian -> Zacian Crowned
    889: 10189  // Zamazenta -> Zamazenta Crowned
};

function getRandomPokemonId() {
    // Elegimos un Pok√©mon que ya est√° en pokemonData
    if (pokemonData.length === 0) return 0; // fallback si todav√≠a no carg√≥ nada
    const keys = Object.keys(pokemonData); // los IDs cargados
    const randKey = keys[Math.floor(Math.random() * keys.length)];
    return parseInt(randKey);
}
function createTile(r, c, allowSound = false) {
    let id = getRandomPokemonId();
    id = getEffectiveId(id);

    const dittoCount = board.flat().filter(t => t && t.isDitto).length;
    const isBerry = Math.random() < 0.05;

    // Ditto especial (solo uno en el tablero)
    const isDitto = !isBerry && dittoCount === 0 && Math.random() < DITTO_CHANCE;

    const isShiny = !isBerry && Math.floor(Math.random() * SHINY_CHANCE) === 0;

    if (isShiny && allowSound) playSparkle();

    return {
        id: isDitto ? 132 : id,   // üî• ID REAL SIEMPRE
        isDitto,
        isShiny,
        isBerry,
        berryType: isBerry
            ? BERRY_TYPES[Math.floor(Math.random() * BERRY_TYPES.length)]
            : null,
        xOffset: 0,
        yOffset: 0,
        isMatch: false,
        scale: 1,
        rotation: 0
    };
}

async function triggerBerryAbility(berry, r, c) {
    let tilesToDestroy = [];

    switch (berry.berryType) {
        case 'CHERI': // Column
            for (let i = 0; i < GRID_SIZE; i++) tilesToDestroy.push({r: i, c: c});
            break;
        case 'CHESTO': // Row
            for (let j = 0; j < GRID_SIZE; j++) tilesToDestroy.push({r: r, c: j});
            break;
        case 'PECHA': // All of same color
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j].id === berry.id) tilesToDestroy.push({r: i, c: j});
                }
            }
            break;
        case 'ORAN': // 3x3 Square
            for (let i = r - 1; i <= r + 1; i++) {
                for (let j = c - 1; j <= c + 1; j++) {
                    if (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE) tilesToDestroy.push({r: i, c: j});
                }
            }
            break;
        case 'RAWST': // Diagonals (X shape)
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.abs(r - i) === Math.abs(c - j)) tilesToDestroy.push({r: i, c: j});
                }
            }
            break;
        case 'SITRUS': // Double Points
    scoreMultiplier = 2;
    
    // UI Elements
    const timerEl = document.getElementById('multiplier-timer');
    const countEl = document.getElementById('timer-count');
    
    statusEl.innerText = '‚ú® 2X POINTS ACTIVE! ‚ú®';
    statusEl.classList.add('shiny-alert');
    timerEl.style.display = 'block';
    
    let timeLeft = 60;
    countEl.innerText = timeLeft;

    // Clear existing timer if one is already running (re-triggering a berry)
    if (multiplierInterval) clearInterval(multiplierInterval);

    multiplierInterval = setInterval(() => {
        timeLeft--;
        countEl.innerText = timeLeft;

        if (timeLeft <= 0) {
            clearInterval(multiplierInterval);
            scoreMultiplier = 1;
            timerEl.style.display = 'none';
            statusEl.classList.remove('shiny-alert');
            updateStatusText();
        }
    }, 1000);
    break;
    }

    if (tilesToDestroy.length > 0) {
        tilesToDestroy.forEach(pos => {
            const t = board[pos.r][pos.c];
            if (!t.isMatch) {
                t.isMatch = true;
                if (t.isShiny) captureShiny(t.id);
            }
        });
        // Increase score based on extra tiles destroyed
        score += tilesToDestroy.length * 50 * scoreMultiplier;
    }
}
function activateBerry(berry, x, y) {
    switch (berry.ability) {
        case 'CHERI': // Column
            for (let i = 0; i < gridHeight; i++) destroyTile(x, i);
            break;

        case 'CHESTO': // Row
            for (let j = 0; j < gridWidth; j++) destroyTile(j, y);
            break;

        case 'PECHA': // Clear same color
            allTiles.forEach(tile => {
                if (tile.color === berry.color) destroyTile(tile.x, tile.y);
            });
            break;

        case 'ORAN': // 3x3 Square
            for (let i = x - 1; i <= x + 1; i++) {
                for (let j = y - 1; j <= y + 1; j++) {
                    if (isValidCoords(i, j)) destroyTile(i, j);
                }
            }
            break;

        case 'RAWST': // Diagonals
            allTiles.forEach(tile => {
                if (Math.abs(tile.x - x) === Math.abs(tile.y - y)) {
                    destroyTile(tile.x, tile.y);
                }
            });
            break;

        case 'SITRUS': // Double score
            scoreMultiplier = 2;
            setTimeout(() => { scoreMultiplier = 1; }, 60000);
            break;
    }
}
function updateStatusText() {
    if (isShinyOnBoard()) {
        statusEl.innerText = '‚ú® SHINY SPAWNED! ‚ú®';
        statusEl.classList.add('shiny-alert'); // opcional animaci√≥n colores
    } else {
        statusEl.innerText = 'SWIPE TO MATCH';
        statusEl.classList.remove('shiny-alert');
    }
}
// --- SISTEMA DE GUARDADO Y CONTINUACI√ìN ---

function checkSaveFile() {
    const save = localStorage.getItem('shinyMatchSave');
    const continueBtn = document.getElementById('continue-btn');
    if (continueBtn) continueBtn.style.display = save ? 'flex' : 'none';
}
function openWho() {
    whoGrid.innerHTML = "";

    pokemonData.forEach(p => {
        const item = document.createElement('div');
        item.className = 'who-item';

        const img = document.createElement('img');
        img.src = p.images.normal.src;
        img.style.width = "64px";
        img.style.imageRendering = "pixelated";

        const name = document.createElement('div');
        name.className = 'who-name';
        name.textContent = p.name;

        item.appendChild(img);
        item.appendChild(name);
        whoGrid.appendChild(item);
    });

    whoModal.style.display = 'flex';
}
function saveGameState() {
    if (gameOver || pokemonData.length === 0) return;
    const gameState = {
        board: board,
        score: score,
        pokemonData: pokemonData.map(p => ({
            id: p.id,
            name: p.name,
            normalSrc: p.images.normal.src,
            shinySrc: p.images.shiny.src,
            cry: p.cry
        })),
        pokemonColors: pokemonColors,
        shinyTrackerHTML: shinyListEl.innerHTML
    };
    localStorage.setItem('shinyMatchSave', JSON.stringify(gameState));
    checkSaveFile();
}

function quitAndSave() {
    saveGameState();
    resetToMenu();
}

function getEffectiveId(id) {
    return FORM_OVERRIDES[id] || id;
}

async function continueGame() {
    const rawData = localStorage.getItem('shinyMatchSave');
    if (!rawData) return;
    const savedData = JSON.parse(rawData);

    mainMenu.style.display = 'none';
    gameScreen.style.display = 'flex';
    loadingEl.style.display = 'flex';

    score = savedData.score;
    scoreEl.innerText = score;
    pokemonColors = savedData.pokemonColors;
    shinyListEl.innerHTML = savedData.shinyTrackerHTML;

    // Recargar im√°genes para el canvas
    pokemonData = [];
    for (const p of savedData.pokemonData) {
        const normal = new Image();
        const shiny = new Image();
        normal.crossOrigin = "anonymous";
        shiny.crossOrigin = "anonymous";
        normal.src = p.normalSrc;
        shiny.src = p.shinySrc;
        await Promise.all([
            new Promise(r => normal.onload = r), 
            new Promise(r => shiny.onload = r)
        ]);
        pokemonData.push({ id: p.id, name: p.name, images: { normal, shiny }, cry: p.cry });
    }

    board = savedData.board;
    resize(); // Ajustar tama√±o al cargar
    loadingEl.style.display = 'none';

    if(!gameInitialized) {
        gameInitialized = true;
        requestAnimationFrame(renderLoop);
        setInterval(checkIdleTime, 1000);
    }
}

// --- L√ìGICA DEL JUEGO ---

async function fetchGameData() {
    try {
        const selectedIds = new Set();
        const ALL_IDS = [...Array.from({length: 1025}, (_, i) => i + 1), ...REGIONAL_IDS];
        const missingShinyIds = ALL_IDS.filter(id => !caughtShinies[id]);

        while (selectedIds.size < 6) {
            let id = (missingShinyIds.length > 0 && Math.random() < 0.7) 
                ? missingShinyIds.splice(Math.floor(Math.random() * missingShinyIds.length), 1)[0]
                : ALL_IDS[Math.floor(Math.random() * ALL_IDS.length)];
            selectedIds.add(id);
        }

        const idArray = Array.from(selectedIds);
        for(let i=0; i < 6; i++) {
            let fetchId = idArray[i];
            const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${fetchId}`);
            const data = await res.json();
            const normal = new Image();
            const shiny = new Image();
            const pName = data.name.replace(/\s+/g, '-');
            normal.crossOrigin = "anonymous";
            shiny.crossOrigin = "anonymous";
            normal.src = data.sprites.front_default || data.sprites.other['official-artwork'].front_default;
            shiny.src = data.sprites.front_shiny || data.sprites.other['official-artwork'].front_shiny;
            await Promise.all([new Promise(r => normal.onload = r), new Promise(r => shiny.onload = r)]);
            pokemonData.push({ name: pName.charAt(0).toUpperCase() + pName.slice(1), images: { normal, shiny }, cry: data.cries ? data.cries.latest : null, id: data.id });
            pokemonColors.push(colors[i]);
        }
    } catch(e) { console.error(e); }
}

function initBoard() {
    resize();
    ensurePlayableBoard();
    lastMoveTime = Date.now();
    if (isShinyOnBoard()) playSparkle();
}

function ensurePlayableBoard() {
    let possible = false;
    while (!possible) {
        for (let r = 0; r < GRID_SIZE; r++) {
            board[r] = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                board[r][c] = createTile(Math.floor(Math.random() * 6), false);
            }
        }
        if (findMatches().length === 0 && hasAnyMove()) possible = true;
    }
}


// --- RENDERIZADO Y RESPONSIVIDAD ---

function resize() {
    const padding = 20;
    const availableWidth = window.innerWidth - padding;
    const availableHeight = window.innerHeight * 0.6;

    const size = Math.min(availableWidth, availableHeight, 500);

    const dpr = window.devicePixelRatio || 1;
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    
    ctx.setTransform(1, 0, 0, 1, 0, 0); // resetear transform
    ctx.scale(dpr, dpr);

    TILE_SIZE = size / GRID_SIZE;
}

function renderLoop() {
    if (gameScreen.style.display === 'none') { 
        requestAnimationFrame(renderLoop); 
        return; 
    }

    // Limpiar canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Dibujar rejilla de fondo
    ctx.strokeStyle = "#334155";
    ctx.lineWidth = 1;
    for(let i = 0; i <= GRID_SIZE; i++){
        ctx.beginPath();
        ctx.moveTo(i * TILE_SIZE, 0);
        ctx.lineTo(i * TILE_SIZE, TILE_SIZE * GRID_SIZE);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i * TILE_SIZE);
        ctx.lineTo(TILE_SIZE * GRID_SIZE, i * TILE_SIZE);
        ctx.stroke();
    }

    // Dibujar piezas
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const tile = board[r][c];

            // Saltar piezas eliminadas
            if (tile.isMatch && tile.scale <= 0) continue;

            const drawX = c * TILE_SIZE + tile.xOffset;
            const drawY = r * TILE_SIZE + tile.yOffset;
            const currentScale = tile.scale !== undefined ? tile.scale : 1;
            const displaySize = TILE_SIZE * currentScale * 0.9;

            // 1. DIBUJAR FONDO DE LA PIEZA
            if (tile.isDitto) {
                // Efecto Arco√≠ris Animado para Ditto
                const hue = (Date.now() / 15) % 360;
                const gradient = ctx.createLinearGradient(drawX, drawY, drawX + TILE_SIZE, drawY + TILE_SIZE);
                gradient.addColorStop(0, `hsl(${hue}, 80%, 60%)`);
                gradient.addColorStop(1, `hsl(${(hue + 60) % 360}, 80%, 60%)`);
                ctx.fillStyle = gradient;
            } else {
                ctx.fillStyle = pokemonColors[tile.id] || "#334155";
            }
            
            ctx.globalAlpha = 1.0;
            ctx.fillRect(drawX + 2, drawY + 2, TILE_SIZE - 4, TILE_SIZE - 4);

            // 2. BORDE SHINY
            if(tile.isShiny){
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 3;
                ctx.strokeRect(drawX + 4, drawY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
            }

            // 3. L√ìGICA DE ROTACI√ìN IDLE
            if(tile === idleRotatingTile && tile.targetRotation != null){
                const rotationSpeed = 0.1;
                if(tile.rotation < tile.targetRotation) tile.rotation += rotationSpeed;
                else {
                    tile.rotation = 0;
                    tile.targetRotation = null;
                    idleRotatingTile = null;
                }
            }

            // 4. DIBUJAR CONTENIDO (DITTO, POKEMON O BAYA)
            ctx.save();
            ctx.translate(drawX + TILE_SIZE / 2, drawY + TILE_SIZE / 2);
            ctx.rotate(tile.rotation || 0);

            if (tile.isBerry) {
                ctx.beginPath();
                ctx.arc(0, 0, displaySize / 2.5, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
                ctx.fill();

                const berryImg = BERRY_SPRITES[tile.berryType];
                if (berryImg) {
                    ctx.imageRendering = "pixelated";
                    ctx.drawImage(berryImg, -displaySize/2.5, -displaySize/2.5, displaySize/1.25, displaySize/1.25);
                }
            } else if (tile.isDitto) {
                // Renderizado especial de Ditto con ID 132
                const imgSource = tile.isShiny 
                    ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/132.png`
                    : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png`;
                
                // Usamos un objeto Image temporal o pre-cargado
                const dittoImg = new Image();
                dittoImg.src = imgSource; 
                
                ctx.imageRendering = "pixelated";
                ctx.drawImage(dittoImg, -displaySize/2, -displaySize/2, displaySize, displaySize);
            } else {
                const pData = pokemonData[tile.id];
                if (pData) {
                    const img = tile.isShiny ? pData.images.shiny : pData.images.normal;
                    ctx.drawImage(img, -displaySize/2, -displaySize/2, displaySize, displaySize);
                }
            }
            ctx.restore();

            // 5. DESTELLOS SHINY ALEATORIOS
            if(tile.isShiny && Math.random() < 0.05){
                spawnSparkle({ ...tile, r, c });
            }
        }
    }

    // Dibujar part√≠culas de destellos
    for(let i = sparkles.length - 1; i >= 0; i--){
        const s = sparkles[i];
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
        ctx.fill();
        s.alpha -= s.decay;
        if(s.alpha <= 0) sparkles.splice(i, 1);
    }

    updateStatusText();
    requestAnimationFrame(renderLoop);
}


// --- INTERACCI√ìN ---

canvas.addEventListener('pointerdown', e => { 
    if (isAnimating || gameOver) return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    
    const rect = canvas.getBoundingClientRect();
    startX = e.clientX; startY = e.clientY;
    
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    // Guardamos la posici√≥n inicial de la celda
    canvas.dataset.startR = Math.floor(clickY / (rect.height / GRID_SIZE));
    canvas.dataset.startC = Math.floor(clickX / (rect.width / GRID_SIZE));
    board.flat().forEach(tile => tile.rotation = 0);
lastMoveTime = Date.now();
});

canvas.addEventListener('pointerup', e => {
    if (isAnimating || gameOver || startX === null) return;
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    const threshold = 30; // Sensibilidad del swipe
    
    const r = parseInt(canvas.dataset.startR);
    const c = parseInt(canvas.dataset.startC);
    
    if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
        let dir = null;
        if (Math.abs(dx) > Math.abs(dy)) {
            if (Math.abs(dx) > threshold) dir = dx > 0 ? 'right' : 'left';
        } else {
            if (Math.abs(dy) > threshold) dir = dy > 0 ? 'down' : 'up';
        }
        if (dir) moveTile(r, c, dir);
    }
    startX = startY = null;
});

// --- L√ìGICA DE MOVIMIENTO Y ANIMACI√ìN ---

async function moveTile(r, c, dir) {
    let tr = r, tc = c;
    if (dir === 'up') tr--; else if (dir === 'down') tr++; 
    else if (dir === 'left') tc--; else if (dir === 'right') tc++;
    
    if (tr >= 0 && tr < GRID_SIZE && tc >= 0 && tc < GRID_SIZE) {
        isAnimating = true;
        await animateSlide(r, c, tr, tc);
        
        // SWAP THE ENTIRE OBJECT
        const temp = board[r][c];
        board[r][c] = board[tr][tc];
        board[tr][tc] = temp;

        // Only process if a REAL match-3 was made
        if (findMatches().length > 0) {
            await processMatches();
            saveGameState();
            if (!hasAnyMove()) endGame();
        } else {
            // Undo: Swap back the entire objects
            await animateSlide(r, c, tr, tc); 
            const swapBack = board[tr][tc];
            board[tr][tc] = board[r][c];
            board[r][c] = swapBack;
        }
        isAnimating = false;
    }
}

async function animateSlide(r1, c1, r2, c2) {
    const duration = 200; const startTime = Date.now();
    const t1 = board[r1][c1]; const t2 = board[r2][c2];
    return new Promise(resolve => {
        function anim() {
            const progress = Math.min((Date.now() - startTime) / duration, 1);
            t1.xOffset = (c2 - c1) * TILE_SIZE * progress; 
            t1.yOffset = (r2 - r1) * TILE_SIZE * progress;
            t2.xOffset = (c1 - c2) * TILE_SIZE * progress; 
            t2.yOffset = (r1 - r2) * TILE_SIZE * progress;
            if (progress < 1) requestAnimationFrame(anim);
            else { t1.xOffset = t1.yOffset = t2.xOffset = t2.yOffset = 0; resolve(); }
        } anim();
    });
}

async function processMatches() {
    let matches = findMatches();
    
    while (matches.length > 0) {
        let tilesToDestroy = new Set();

        // 1. Check all matches and identify Berry AoE patterns
        matches.forEach(m => {
            const tile = board[m.r][m.c];
            if (!tile.isMatch) {
                tilesToDestroy.add(`${m.r},${m.c}`);
                
                if (tile.isBerry) {
                    // ACTIVATE SITRUS TIMER IF MATCHED
                    if (tile.berryType === 'SITRUS') {
                        activateSitrusTimer();
                    }
                    
                    const pattern = getBerryPattern(tile, m.r, m.c);
                    pattern.forEach(pos => {
                        // If the berry explosion hits OTHER berries, trigger them too
                        const hitTile = board[pos.r][pos.c];
                        if (hitTile.isBerry && !tilesToDestroy.has(`${pos.r},${pos.c}`)) {
                             if (hitTile.berryType === 'SITRUS') activateSitrusTimer();
                        }
                        tilesToDestroy.add(`${pos.r},${pos.c}`);
                    });
                }
            }
        });

        // 2. Process all marked tiles
        tilesToDestroy.forEach(posKey => {
            const [r, c] = posKey.split(',').map(Number);
            const tile = board[r][c];

            if (!tile.isMatch) {
                tile.isMatch = true;
                let tileScore = 100; // base
        if (tile.isShiny) tileScore = 200; // + puntos extra para Shiny
        score += tileScore * scoreMultiplier;

                // Capture if shiny
                if (tile.isShiny && !tile.isDitto) {
                    captureShiny(tile.id);
                    const pData = pokemonData[tile.id];
                    if (pData.cry && !isMuted) {
                        const crySound = new Audio(pData.cry);
                        crySound.volume = 0.5;
                        crySound.play().catch(() => {});
                    }
                } else if (!isMuted && !tile.isBerry) {
                    POP_SOUND_SOFT.currentTime = 0;
                    POP_SOUND_SOFT.play().catch(() => {});
                }
            }
        });

        // 3. Score Calculation
        score += tilesToDestroy.size * 100 * scoreMultiplier;
        scoreEl.innerText = score;

        // 4. Animation and Refill
        await animateShrink(Array.from(tilesToDestroy).map(key => {
            const [r, c] = key.split(',').map(Number);
            return { r, c };
        }));

        // Gravity Logic
        for (let c = 0; c < GRID_SIZE; c++) {
            let empty = 0;
            for (let r = GRID_SIZE - 1; r >= 0; r--) {
                if (board[r][c].isMatch) {
                    empty++;
                } else if (empty > 0) {
                    board[r + empty][c] = { ...board[r][c], yOffset: -empty * TILE_SIZE, isMatch: false, scale: 1 };
                    board[r][c] = { isMatch: true };
                }
            }
            for (let r = 0; r < empty; r++) {
    // Aqu√≠ es donde se crean las piezas nuevas que caen
    board[r][c] = createTile(Math.floor(Math.random() * 6), true);
    board[r][c].yOffset = -empty * TILE_SIZE;
}
        }

        await animateFalling();
        
        // Re-check for chain reactions
        matches = findMatches();
        updateStatusText();
    }
}
function resetSitrusEffect() {
    if (multiplierInterval) {
        clearInterval(multiplierInterval);
        multiplierInterval = null;
    }
    scoreMultiplier = 1;
    
    // UI Cleanup
    const timerEl = document.getElementById('multiplier-timer');
    const statusEl = document.getElementById('status');
    
    if (timerEl) timerEl.style.display = 'none';
    if (statusEl) {
        statusEl.classList.remove('shiny-alert');
        statusEl.innerText = "SWIPE TO MATCH";
    }
}
/** * Helper function to calculate which coordinates a berry hits
 */
function getBerryPattern(berry, r, c) {
    let pattern = [];
    switch (berry.berryType) {
        case 'CHERI': // Column
            for (let i = 0; i < GRID_SIZE; i++) pattern.push({ r: i, c: c });
            break;
        case 'CHESTO': // Row
            for (let j = 0; j < GRID_SIZE; j++) pattern.push({ r: r, c: j });
            break;
        case 'PECHA': // Same Color
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j].id === berry.id) pattern.push({ r: i, c: j });
                }
            }
            break;
        case 'ORAN': // 3x3
            for (let i = r - 1; i <= r + 1; i++) {
                for (let j = c - 1; j <= c + 1; j++) {
                    if (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE) pattern.push({ r: i, c: j });
                }
            }
            break;
        case 'RAWST': // Diagonals
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.abs(r - i) === Math.abs(c - j)) pattern.push({ r: i, c: j });
                }
            }
            break;
        case 'SITRUS': // Double Points
            scoreMultiplier = 2;
            statusEl.innerText = '‚ú® 2X POINTS ACTIVE! ‚ú®';
            statusEl.classList.add('shiny-alert');
            setTimeout(() => {
                scoreMultiplier = 1;
                updateStatusText();
            }, 60000);
            break;
    }
    return pattern;
}

async function animateShrink(matches) {
    const duration = 250; const startTime = Date.now();
    return new Promise(resolve => {
        function anim() {
            const progress = Math.min((Date.now() - startTime) / duration, 1);
            matches.forEach(m => { 
                board[m.r][m.c].scale = 1 - progress; 
            });
            if (progress < 1) requestAnimationFrame(anim); else resolve();
        } anim();
    });
}

async function animateFalling() {
    const duration = 300; const startTime = Date.now();
    return new Promise(resolve => {
        function anim() {
            const progress = Math.min((Date.now() - startTime) / duration, 1);
            let stillMoving = false;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c].yOffset < 0) {
                        board[r][c].yOffset += (TILE_SIZE * 0.12);
                        if (board[r][c].yOffset > 0) board[r][c].yOffset = 0;
                        stillMoving = true;
                    }
                }
            }
            if (stillMoving) requestAnimationFrame(anim); else resolve();
        } anim();
    });
}

// --- UTILIDADES RESTANTES ---

function findMatches() {
    let matches = [];
    
    const areCompatible = (t1, t2) => {
        if (t1.isMatch || t2.isMatch) return false;
        if (t1.isDitto || t2.isDitto) return true; // Ditto matchea con todo
        return t1.id === t2.id;
    };

    // Horizontal
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE - 2; c++) {
            let t1 = board[r][c], t2 = board[r][c+1], t3 = board[r][c+2];
            
            // L√≥gica: Si t1 y t2 son compatibles, y t2 y t3 son compatibles...
            // Pero necesitamos asegurar que al menos uno NO sea Ditto para saber el color,
            // o que si todos son Ditto, cuenten como match.
            if (areCompatible(t1, t2) && areCompatible(t2, t3)) {
                // Caso especial: si hay Dittos, confirmar que los colores reales presentes coincidan
                let nonDittoTiles = [t1, t2, t3].filter(t => !t.isDitto);
                let colorsPresent = new Set(nonDittoTiles.map(t => t.id));
                
                if (colorsPresent.size <= 1) { // 0 colores (todo ditto) o 1 color dominante
                    if (!(t1.isBerry && t2.isBerry && t3.isBerry)) {
                        matches.push({r, c}, {r, c:c+1}, {r, c:c+2});
                    }
                }
            }
        }
    }
    
    // Vertical (misma l√≥gica aplicada)
    for (let c = 0; c < GRID_SIZE; c++) {
        for (let r = 0; r < GRID_SIZE - 2; r++) {
            let t1 = board[r][c], t2 = board[r+1][c], t3 = board[r+2][c];
            if (areCompatible(t1, t2) && areCompatible(t2, t3)) {
                let nonDittoTiles = [t1, t2, t3].filter(t => !t.isDitto);
                let colorsPresent = new Set(nonDittoTiles.map(t => t.id));
                if (colorsPresent.size <= 1) {
                    if (!(t1.isBerry && t2.isBerry && t3.isBerry)) {
                        matches.push({r, c}, {r:r+1, c}, {r:r+2, c});
                    }
                }
            }
        }
    }
    return matches;
}

function hasAnyMove() {
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            if (c < GRID_SIZE - 1 && checkPotential(r, c, r, c + 1)) return true;
            if (r < GRID_SIZE - 1 && checkPotential(r, c, r + 1, c)) return true;
        }
    }
    return false;
}

function checkPotential(r1, c1, r2, c2) {
    const t1 = board[r1][c1].id;
    const t2 = board[r2][c2].id;
    board[r1][c1].id = t2;
    board[r2][c2].id = t1;
    const matches = findMatches();
    board[r1][c1].id = t1;
    board[r2][c2].id = t2;
    return matches.length > 0;
}


function captureShiny(tileId, isDitto = false) {
    let pInfo;
    if (isDitto) {
        // Datos gen√©ricos para Ditto Shiny si quieres que aparezca
        pInfo = { 
            id: 132, 
            name: 'Ditto', 
            images: { shiny: { src: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/132.png' } } 
        };
    } else {
        pInfo = pokemonData[tileId];
    }
    if (!caughtShinies[pInfo.id]) { 
        caughtShinies[pInfo.id] = pInfo.images.shiny.src; 
        localStorage.setItem('shinyDex', JSON.stringify(caughtShinies)); 
    }
    const img = document.createElement('img'); 
    img.src = pInfo.images.shiny.src; 
    img.className = 'shiny-icon';
    shinyListEl.appendChild(img); 
    finalShinyListEl.appendChild(img.cloneNode());

}

function isShinyOnBoard() { return board.some(row => row.some(tile => tile.isShiny && !tile.isMatch)); }
function playSparkle() { if (!isMuted) { SHINY_SOUND.currentTime = 0; SHINY_SOUND.play().catch(()=>{}); } }
function resetToMenu() { resetSitrusEffect(); gameScreen.style.display = 'none'; mainMenu.style.display = 'block'; checkSaveFile(); }
function endGame() { gameOver = true; finalScoreEl.innerText = score; gameOverOverlay.style.display = 'flex'; localStorage.removeItem('shinyMatchSave'); checkSaveFile(); }

async function startGame() {
    resetSitrusEffect();
    mainMenu.style.display = 'none'; 
    gameOverOverlay.style.display = 'none'; 
    gameScreen.style.display = 'flex'; 
    loadingEl.style.display = 'flex';
    
    // Reset game state
    pokemonData = []; 
    pokemonColors = []; 
    sparkles = []; 
    score = 0; 
    scoreEl.innerText = "0"; 
    gameOver = false;
    shinyListEl.innerHTML = ""; 
    finalShinyListEl.innerHTML = "";
    
    // Load Berries AND Pokemon data simultaneously
    await Promise.all([fetchGameData(), preloadBerries()]);

    if (pokemonData.length > 0) {
        initBoard(); 
        loadingEl.style.display = 'none';
        if(!gameInitialized) { 
            gameInitialized = true; 
            requestAnimationFrame(renderLoop); 
            setInterval(checkIdleTime, 1000); 
        }
    } else { 
        alert("Error loading Pok√©mon."); 
        resetToMenu(); 
    }
}

function openDex() {
    dexGrid.innerHTML = "";
    dexCount.innerText = `COLLECTED: ${Object.keys(caughtShinies).length}`;

    // Pok√©mon base (1-1025)
    for (let id = 1; id <= 1025; id++) {
        dexGrid.appendChild(createDexSlot(id, false)); // 'false' porque no es regional
    }

    // Pok√©mon regionales con numeraci√≥n R-1, R-2...
    REGIONAL_IDS.forEach((id, index) => {
        // Pasamos el id y el n√∫mero de orden (index + 1)
        dexGrid.appendChild(createDexSlot(id, index + 1)); 
    });

    dexModal.style.display = 'flex';
}
function createDexSlot(id, regionalOrder) {
    const slot = document.createElement('div');
    slot.className = 'dex-slot';
    
    // Get the visual ID (Crowned/Hero/Core)
    const visualId = getEffectiveId(id);

    const numberTag = document.createElement('span');
    numberTag.className = 'dex-number';
    numberTag.innerText = regionalOrder ? `R-${regionalOrder}` : id;

    const img = document.createElement('img');
    img.className = 'dex-img';

    if (caughtShinies[id]) {
        // Use the Shiny Sprite of the Hero/Crowned form
        img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/${visualId}.png`;
    } else {
        // Silhouette: Use the normal sprite of the Hero/Crowned form
        img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${visualId}.png`;
        slot.classList.add('not-caught');
    }

    slot.appendChild(numberTag);
    slot.appendChild(img);
    return slot;
}

function closeModals() {
    dexModal.style.display = 'none';
    whoModal.style.display = 'none';
}
function toggleMute() { isMuted = !isMuted; muteBtn.innerText = isMuted ? 'üîá' : 'üîä'; }

function spawnSparkle(tile) {
    const drawX = tile.c * TILE_SIZE + TILE_SIZE/2;
    const drawY = tile.r * TILE_SIZE + TILE_SIZE/2;
    sparkles.push({
        x: drawX + (Math.random()-0.5)*TILE_SIZE*0.6,
        y: drawY + (Math.random()-0.5)*TILE_SIZE*0.6,
        radius: Math.random()*2 + 1,
        alpha: 1,
        decay: Math.random()*0.03 + 0.01
    });
}

function findFirstHint() {
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            // Check Horizontal: si (r,c) y (r, c+1) pueden generar match
            if (c < GRID_SIZE - 1 && checkPotential(r, c, r, c + 1)) {
                // Devolvemos solo la de la izquierda (o podr√≠as usar Math.random() para variar)
                return board[r][c]; 
            }
            // Check Vertical: si (r,c) y (r+1, c) pueden generar match
            if (r < GRID_SIZE - 1 && checkPotential(r, c, r + 1, c)) {
                // Devolvemos solo la de arriba
                return board[r][c];
            }
        }
    }
    return null;
}

/**
 * Gestiona la animaci√≥n de sugerencia por inactividad.
 */
function checkIdleTime() {
    const IDLE_THRESHOLD = 10000; // 10 segundos
    const isIdle = (Date.now() - lastMoveTime) > IDLE_THRESHOLD;

    // Si el usuario se movi√≥, reseteamos la referencia y salimos
    if (!isIdle) {
        idleRotatingTile = null;
        return;
    }

    // Si ya hay una pieza rotando, no buscamos m√°s
    if (idleRotatingTile) return;

    // Buscamos solo UNA sugerencia
    const hintTile = findFirstHint();

    if (hintTile) {
        idleRotatingTile = hintTile;
        // Aplicamos la rotaci√≥n (360 grados en radianes)
        idleRotatingTile.targetRotation = idleRotatingTile.rotation + (2 * Math.PI);
    }
}
function continueBoard() {
    // Oculta el overlay del mensaje
    gameOverOverlay.style.display = 'none';
    
    // Aseg√∫rate de que el tablero siga visible
    gameScreen.style.display = 'flex';
    
    // Resetea cualquier estado de animaci√≥n si fuese necesario
    isAnimating = false;
    
    // Vuelve a actualizar el canvas por si algo qued√≥ parado
    requestAnimationFrame(renderLoop);
}

function checkAllShiniesCollected() {
    if (allShiniesMessageShown) return; // si ya se mostr√≥, no hacemos nada

    // Contamos solo los shinies de la partida actual
    const capturedThisBoard = new Set();
    for (let i = 0; i < finalShinyListEl.children.length; i++) {
        const src = finalShinyListEl.children[i].src;
        capturedThisBoard.add(src);
    }

}
function openBerryGuide() {
    const guideList = document.getElementById('berry-guide-list');
    guideList.innerHTML = "";

    const descriptions = {
        'CHERI': 'Clears the entire COLUMN.',
        'CHESTO': 'Clears the entire ROW.',
        'PECHA': 'Clears ALL Pok√©mon of the same color.',
        'ORAN': 'Explodes in a 3x3 SQUARE area.',
        'RAWST': 'Clears tiles in an X-SHAPED diagonal.',
        'SITRUS': 'DOUBLE POINTS for 60 seconds!'
    };

    BERRY_TYPES.forEach(type => {
        const row = document.createElement('div');
        row.className = 'berry-row';
        
        const img = new Image();
        img.src = BERRY_SPRITES[type].src;
        
        const info = document.createElement('div');
        info.className = 'berry-info';
        info.innerHTML = `<h4>${type} BERRY</h4><p>${descriptions[type]}</p>`;
        
        row.appendChild(img);
        row.appendChild(info);
        guideList.appendChild(row);
    });

    document.getElementById('berry-modal').style.display = 'flex';
}
function openTutorial() {
    tutorialModal.style.display = 'flex';
}
// Update your closeModals to include this new one
function closeModals() {
    document.getElementById('dex-modal').style.display = 'none';
    document.getElementById('who-modal').style.display = 'none';
    document.getElementById('berry-modal').style.display = 'none';
    document.getElementById('tutorial-modal').style.display = 'none';
}
window.addEventListener('resize', () => { resize(); });
window.addEventListener('load', checkSaveFile);
</script>
</body>
</html>
